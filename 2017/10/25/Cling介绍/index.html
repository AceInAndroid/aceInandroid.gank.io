<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.png?v=5.1.3" color="#222">





  <meta name="keywords" content="欢迎来到zhangbing的酒馆,来了就坐下吧" />










<meta name="description" content="1. 简单使用为了满足手机与TV端相互交互分享图片在TV上播放的需求,在了解了一番技术选型之后,选用了基于DLNA的UPnP协议的Cling这个库.">
<meta name="keywords" content="前端,android,jquery,javascript,html5,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验">
<meta property="og:type" content="article">
<meta property="og:title" content="Android投屏,同屏库Cling源码使用和解析">
<meta property="og:url" content="http://www.azhangbing.com/2017/10/25/Cling介绍/index.html">
<meta property="og:site_name" content="Ace的技术客栈">
<meta property="og:description" content="1. 简单使用为了满足手机与TV端相互交互分享图片在TV上播放的需求,在了解了一番技术选型之后,选用了基于DLNA的UPnP协议的Cling这个库.">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://oy261wvqm.bkt.clouddn.com/2017-10-25-control_flow.png">
<meta property="og:image" content="http://oy261wvqm.bkt.clouddn.com/2017-10-25-15089023672484.png">
<meta property="og:updated_time" content="2017-11-03T02:08:14.885Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android投屏,同屏库Cling源码使用和解析">
<meta name="twitter:description" content="1. 简单使用为了满足手机与TV端相互交互分享图片在TV上播放的需求,在了解了一番技术选型之后,选用了基于DLNA的UPnP协议的Cling这个库.">
<meta name="twitter:image" content="http://oy261wvqm.bkt.clouddn.com/2017-10-25-control_flow.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.azhangbing.com/2017/10/25/Cling介绍/"/>





  <title>Android投屏,同屏库Cling源码使用和解析 | Ace的技术客栈</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f4df925f5ecaae00a62621ca00acdaae";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ace的技术客栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">业精于勤荒于嬉 行成于思毁于随</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.azhangbing.com/2017/10/25/Cling介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ace的技术客栈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Android投屏,同屏库Cling源码使用和解析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-25T14:41:51+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h2><p>为了满足手机与TV端相互交互分享图片在TV上播放的需求,在了解了一番技术选型之后,选用了基于DLNA的UPnP协议的<a href="https://github.com/4thline/cling" target="_blank" rel="external">Cling</a>这个库.</p>
<a id="more"></a>
<p>(1) 定义自己的 UpnpService 类，继承自 AndroidUpnpServiceImpl<br>(2) 启动该 Service,同时启动jetty资源服务器<br>(3) 从 UpnpService 中获取 ControlPoint，并搜索设备</p>
<p>搜索注册在同局域网的所有设备。</p>
<pre><code>    private ServiceConnection serviceConnection = new ServiceConnection() {

        public void onServiceConnected(ComponentName className, IBinder service) {
            isBind = true;
            upnpService = (AndroidUpnpService) service;
            ....
upnpService.getRegistry().addListener(registryListener);
            ....
            // 搜索局域网内设备
upnpService.getControlPoint().search();
        }
      ...
    };

 private RegistryListener registryListener = new RegistryListener() {
    ....
            @Override
        public void localDeviceAdded(Registry registry, LocalDevice localDevice) {
           ....
           //注册接收TV设备消息的回调
           localService.getManager().getImplementation().setiControlCallback(innerCallback);
              ....
        }


        @Override
        public void remoteDeviceAdded(Registry registry, RemoteDevice remoteDevice) {
            //添加搜索到的设备到remoteDevices
            remoteDevices.add(remoteDevice);
        }

      ......
       };
</code></pre><p>然后根据和家相册TV独有的字段过滤</p>
<pre><code>    /**
     * 过滤感兴趣的设备
     * @return 
     */
    public List&lt;Device&gt; getDmrDevices() {
        List&lt;Device&gt; devices = new ArrayList&lt;&gt;();
        List&lt;Device&gt; mdevices = new ArrayList&lt;&gt;();
        devices.addAll(remoteDevices);
        for (int i = 0; i &lt; devices.size(); i++) {
            if (!dmrDeviceType.equals(devices.get(i).getType())) {
                continue;
            }
            String devices_uuid = devices.get(i).getIdentity().getUdn().toString();
            String localuuid = LocalDeviceFactoty.uniqueSystemIdentifier(LocalDeviceFactoty.DMR_KEY).toString();
            if (!devices_uuid.equals(localuuid)) {
            //过滤我们感兴趣的设备
                if (devices_uuid.contains(&quot;-dmp&quot;))
                    mdevices.add(devices.get(i));
            }
        }
        return mdevices;
    }
</code></pre><p>连接电视</p>
<pre><code>    public void connecttotv(Device device, Handler handler) {
        String data = &quot;&quot;;
        JSONObject jsonObject = new JSONObject();

            try {
                jsonObject.put(&quot;tv_uuid&quot;, device.getIdentity().getUdn().getIdentifierString());
                jsonObject.put(&quot;phone_uuid&quot;, DevicesManager.getInstance().getDmsDeviceIdentifierString());
                jsonObject.put(&quot;phone_model&quot;, Utils.getDevName());
                jsonObject.put(&quot;phone_ip&quot;, getPhoneIP());
                data = jsonObject.toString();
            } catch (JSONException e) {
                e.printStackTrace();
            }
            sendtoTV(device.getIdentity().getUdn().getIdentifierString(), Constants.TYPE_CONNECT, data, handler);
    }
</code></pre><p>sendtoTV()方法</p>
<pre><code> //查找设备的方法
            Service service = device.findService(simpleParamServiceId);
            if (service != null) {
                targetService = service;
                break;
            }
        }

        SendSimpleParamActionCallback callback = new SendSimpleParamActionCallback(targetService, str);
        callback.setiServiceResult(iServiceResult);

        upnpService().getControlPoint().execute(callback)
</code></pre><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h2><h3 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h3><h4 id="2-1-1-概述"><a href="#2-1-1-概述" class="headerlink" title="2.1.1 概述"></a>2.1.1 概述</h4><p>Cling 作为 UPnP 协议栈，其主旨即是在设备的发现，控制等过程中对不同的协议及内容进行处理。UPnP 协议栈由多个层组成，Cling 只关心底层的 TCP/IP 协议以及包含 SSDP（设备发现），SOAP（设备控制），GENA（设备事件）协议的层。</p>
<h4 id="2-1-2-使用场景"><a href="#2-1-2-使用场景" class="headerlink" title="2.1.2 使用场景"></a>2.1.2 使用场景</h4><blockquote>
<ul>
<li>手机加入到局域网中，建立 MulticastSocket 监听局域网中设备</li>
<li>手机 向多播发出 M-SEARCH 报文</li>
<li>和家相册TV端 获取局域网中手机发出的报文，判断是否符合条件，若符合向手机回应 OK 报文，报文中包含 description,URL,uuid,udn等信息(封装在Device里)</li>
<li>手机 监听局域网获取到相关报文，并通过 URL 获得设备描述信息判断是不是自己感兴趣</li>
<li>手机 通过 Jetty Service 将媒体内容的HTTP链接推送到 和家相册TV端并播放</li>
</ul>
</blockquote>
<h4 id="2-1-3-设备发现及控制流程"><a href="#2-1-3-设备发现及控制流程" class="headerlink" title="2.1.3 设备发现及控制流程"></a>2.1.3 设备发现及控制流程</h4><p><img src="http://oy261wvqm.bkt.clouddn.com/2017-10-25-control_flow.png" alt="control_flo"></p>
<h4 id="2-1-4-类关系图"><a href="#2-1-4-类关系图" class="headerlink" title="2.1.4 类关系图"></a>2.1.4 类关系图</h4><p><img src="http://oy261wvqm.bkt.clouddn.com/2017-10-25-15089023672484.png" alt=""></p>
<h4 id="2-1-5-类功能详细介绍"><a href="#2-1-5-类功能详细介绍" class="headerlink" title="2.1.5 类功能详细介绍"></a>2.1.5 类功能详细介绍</h4><blockquote>
<p>由类图可知，Cling 的一切都是从 UpnpService 开始的，其中包含了 ControlPoint，ProtocolFactory，Registry，Router 四个核心模块，以及一个配置信息类 UpnpServiceConfiguration。<br>ControlPoint<br>控制点的接口，主要功能是异步执行搜索，设备控制订阅等指令。<br>此接口定义了查找设备，向设备发送指令，订阅设备变更，其实现类只有一个为 ControlPointImpl。</p>
</blockquote>
<h5 id="2-1-5-1-ControlPoint"><a href="#2-1-5-1-ControlPoint" class="headerlink" title="2.1.5.1 ControlPoint"></a>2.1.5.1 ControlPoint</h5><h6 id="1-查找"><a href="#1-查找" class="headerlink" title="(1) 查找"></a>(1) 查找</h6><pre><code>public void search(UpnpHeader searchType, int mxSeconds);
</code></pre><p>第一个参数UpnpHeader表示查询条件，第二个参数表示最大超时时间，以秒为单位。<br>UpnpHeader 是一个抽象类，其中定义了包含每个过程请求中的 Header 信息的枚举类型Type以及泛型 value，查询时常用的实现类有：DeviceTypeHeader，UDNHeader 等，可根据设备类型、UDN、服务类型等多种方式。</p>
<h6 id="2-执行控制指令"><a href="#2-执行控制指令" class="headerlink" title="(2) 执行控制指令"></a>(2) 执行控制指令</h6><pre><code>public Future execute(ActionCallback callback);
</code></pre><p>将 ActionCallback 放入 DefaultUpnpServiceConfiguration 中定义的线程池 <strong>ClingExecutor</strong> 执行，执行完毕回调 ActionCallback 中定义的 success 或 failure 函数。<br>ActionCallback 是命令执行的回调接口，在其 run 方法内会根据是本地命令还是远程命令进行执行，执行结束后回调成功或失败接口。</p>
<h6 id="3-执行事件订阅指令"><a href="#3-执行事件订阅指令" class="headerlink" title="(3) 执行事件订阅指令"></a>(3) 执行事件订阅指令</h6><pre><code>public void execute(SubscriptionCallback callback);
</code></pre><p>将 SubscriptionCallback 放入 DefaultUpnpServiceConfiguration 中定义的线程池 ClingExecutor 执行，执行完毕回调 ActionCallback 中定义的 established、failed、ended 等函数。</p>
<h5 id="2-1-5-2-ProtocolFactory"><a href="#2-1-5-2-ProtocolFactory" class="headerlink" title="2.1.5.2 ProtocolFactory"></a>2.1.5.2 ProtocolFactory</h5><p>UPnP 协议的工厂类，用于根据收到的 UPnP 协议或是本地设备的 meta 信息，创建一个可执行的协议。<br>使用简单工厂模式封装协议内容的处理，实现类为 ProtocolFactoryImpl，主要根据接收报文和发送报文两大类创建不同协议。</p>
<p>在该类中 UDP 包通过 createReceivingAsync() 方法对传递来的 IncomingDatagramMessage 进行处理，如 NOTIFY–ReceivingNotification，MSEARCH–ReceivingSearch。<br>TCP 包通过 createReceivingSync 进行分发处理，并通过 ReceivingSync 的子类进行处理，子类中调用 executeSync 方法等待并返回 response。</p>
<h6 id="1-处理接收到的报文"><a href="#1-处理接收到的报文" class="headerlink" title="(1) 处理接收到的报文"></a>(1) 处理接收到的报文</h6><pre><code>public ReceivingAsync createReceivingAsync(IncomingDatagramMessage message);
</code></pre><p>IncomingDatagramMessage 封装了 UDP 包的信息，在 createReceivingAsync 中根据消息的操作类型及方法创建不同的 ReceivingAsync 子类对象，ReceivingAsync 子类通过重写 execute 方法定义具体实现。如请求的 NOTIFY 信息创建 ReceivingNotification，请求的 MSEARCH 创建 ReceivingSearch。</p>
<pre><code>public ReceivingSync createReceivingSync(StreamRequestMessage message);
</code></pre><p>StreamRequestMessage 封装 TCP 报文，在 createReceivingSync 中根据消息的操作类型方法及 UPnP 服务 NameSpace 等的配置创建不同的 ReceivingSync 的子类对象，ReceivingSync 子类通过重写 executeSync 方法定义具体实现。</p>
<h6 id="2-组装发送的报文"><a href="#2-组装发送的报文" class="headerlink" title="(2) 组装发送的报文"></a>(2) 组装发送的报文</h6><p>有若干功能类似的方法，返回不同的 SendingAsync 子类对象，通过重写 executeSync 方法定义具体实现。如：</p>
<blockquote>
<ol>
<li>向组播发送 ssdp:alive 告知设备存活<br>public SendingNotificationAlive createSendingNotificationAlive(LocalDevice localDevice)</li>
<li>生产 SendingSearch 实例的工厂方法，SendingSearch 中定义了查询条件以及请求超时时间，在重写的 execute 函数中，在线程启动后创建 OutgoingSearchRequest 对象并通过 Router 发送。</li>
</ol>
</blockquote>
<pre><code>public SendingSearch createSendingSearch(UpnpHeader searchTarget, int mxSeconds);
</code></pre><h5 id="2-1-5-3-Registry"><a href="#2-1-5-3-Registry" class="headerlink" title="2.1.5.3 Registry"></a>2.1.5.3 Registry</h5><p>设备资源管理器，用于设备、资源、订阅消息的管理，包括添加、更新、移除、查询。可将新设备时加入 Registry 中，在设备失效后从 Registry 中移除。目前实现类为 RegistryImpl。<br>关联类包括：RegistryListener、Resource、RegistryItem、RegistryItems、LocalItems、RemoteItems、ExpirationDetails、RegistryMaintainer。</p>
<h5 id="2-1-5-4-RegistryListener"><a href="#2-1-5-4-RegistryListener" class="headerlink" title="2.1.5.4 RegistryListener"></a>2.1.5.4 RegistryListener</h5><p>设备状态监听类，包含本地/远程设备的发现、添加、更新、移除等回调函数。可通过<br>addListener(RegistryListener listener)<br>添加，保存在RegistryListener的 Set\ registryListener 参数内。<br>实现类有空实现的 DefaultRegistryListener 以及通过注入属性实现的 RegistryListenerAdapter。</p>
<h5 id="2-1-5-5-Resource"><a href="#2-1-5-5-Resource" class="headerlink" title="2.1.5.5 Resource"></a>2.1.5.5 Resource</h5><p>资源的父类。该类中定义资源的 URI，model 等属性。</p>
<h5 id="2-1-5-6-RegistryItem"><a href="#2-1-5-6-RegistryItem" class="headerlink" title="2.1.5.6 RegistryItem"></a>2.1.5.6 RegistryItem</h5><p>KV 形式的数据项，在 RegistryImpl 中用于包装设备、资源、订阅消息等。</p>
<h5 id="2-1-5-7-RegistryItems"><a href="#2-1-5-7-RegistryItems" class="headerlink" title="2.1.5.7 RegistryItems"></a>2.1.5.7 RegistryItems</h5><p>RegistryImpl中设备、资源集合的父类，定义了对元素的增删查改等操作。<br>包含deviceItems和subscriptionItems两个属性，分别表示设备集合和订阅消息集合，集合元素为RegistryItem。<br>子类有LocalItems和RemoteItems分别表示本地设备和远程设备集合。</p>
<h5 id="2-1-5-8-LocalItems"><a href="#2-1-5-8-LocalItems" class="headerlink" title="2.1.5.8 LocalItems"></a>2.1.5.8 LocalItems</h5><p>继承自 RegistryItems，key 为 LocalDevice，value 为 LocalGENASubscription。存储本地设备及其订阅消息。</p>
<h5 id="2-1-5-9-RemoteItems"><a href="#2-1-5-9-RemoteItems" class="headerlink" title="2.1.5.9 RemoteItems"></a>2.1.5.9 RemoteItems</h5><p>继承自 RegistryItems，key 为 RemoteDevice，value 为 RemoteGENASubscription。存储远程设备及其订阅消息。</p>
<h5 id="2-1-5-10-xpirationDetails"><a href="#2-1-5-10-xpirationDetails" class="headerlink" title="2.1.5.10 xpirationDetails"></a>2.1.5.10 xpirationDetails</h5><p>为 RegistryItem 的属性，记录上次刷新和最大超时时间，从而判断对象是否过期。</p>
<h5 id="2-1-5-11-RegistryMaintainer"><a href="#2-1-5-11-RegistryMaintainer" class="headerlink" title="2.1.5.11 RegistryMaintainer"></a>2.1.5.11 RegistryMaintainer</h5><p>资源管理器中元素有效期的定期维护，每隔 1000ms 调用一次 registry.maintain() 方法，该方法执行的操作有：</p>
<h6 id="1-判断过期的-item，并从-resourceItems-中移除；"><a href="#1-判断过期的-item，并从-resourceItems-中移除；" class="headerlink" title="(1) 判断过期的 item，并从 resourceItems 中移除；"></a>(1) 判断过期的 item，并从 resourceItems 中移除；</h6><h6 id="2-遍历-resourceItems，对其中的每个-Resource-调用其-maintain-方法；"><a href="#2-遍历-resourceItems，对其中的每个-Resource-调用其-maintain-方法；" class="headerlink" title="(2) 遍历 resourceItems，对其中的每个 Resource 调用其 maintain() 方法；"></a>(2) 遍历 resourceItems，对其中的每个 Resource 调用其 maintain() 方法；</h6><h6 id="3-remoteItems-maintain-对-remote-进行维护；"><a href="#3-remoteItems-maintain-对-remote-进行维护；" class="headerlink" title="(3) remoteItems.maintain() 对 remote 进行维护；"></a>(3) remoteItems.maintain() 对 remote 进行维护；</h6><h6 id="4-localItems-maintain-对-local-进行维护；"><a href="#4-localItems-maintain-对-local-进行维护；" class="headerlink" title="(4) localItems.maintain() 对 local 进行维护；"></a>(4) localItems.maintain() 对 local 进行维护；</h6><h6 id="5-runPendingExecutions-执行异步任务。"><a href="#5-runPendingExecutions-执行异步任务。" class="headerlink" title="(5) runPendingExecutions 执行异步任务。"></a>(5) runPendingExecutions 执行异步任务。</h6><h5 id="2-1-5-12-Router"><a href="#2-1-5-12-Router" class="headerlink" title="2.1.5.12 Router"></a>2.1.5.12 Router</h5><p>数据传输层接口，负责接收和发送 UPnP 和 UDP 消息，或者将接收到的数据流广播给局域网内的其他设备。<br>目前实现类为 RouterImpl 和 MockRouter，其中 MockRouter 仅用来作为测试时的 Mock 接口，RouterImpl 作为默认的数据传输层实现。</p>
<h6 id="1-enable"><a href="#1-enable" class="headerlink" title="(1) enable()"></a>(1) enable()</h6><p>启动。<br>得到配置中的NetworkAddressFactory，其目前实现为NetworkAddressFactoryImpl，调用startInterfaceBasedTransports()为NetworkAddressFactory的每个网络接口绑定一个多播接收器MulticastReceiver，用来监听多播地址，并处理获取到的数据。<br>KV 形式存储在multicastReceivers中;调用startAddressBasedTransportsNetworkAddressFactory的每个地址绑定一个StreamServer和DatagramIO，监听并进行数据处理。KV 形式存储在streamServers中。创建一个StreamClient用于发送 TCP 消息。</p>
<h6 id="2-disable"><a href="#2-disable" class="headerlink" title="(2) disable()"></a>(2) disable()</h6><p>停止。<br>停止StreamClient，停止streamServers中每个StreamServer，停止multicastReceivers中每个MulticastReceiver，停止datagramIOs中每个DatagramIO。<br>通过可重入锁写锁控制启动和停止的并发。</p>
<h6 id="3-getActiveStreamServers-InetAddress-preferredAddress"><a href="#3-getActiveStreamServers-InetAddress-preferredAddress" class="headerlink" title="(3) getActiveStreamServers(InetAddress preferredAddress)"></a>(3) getActiveStreamServers(InetAddress preferredAddress)</h6><p>根据 preferredAddress 得到活跃的 StreamServer，如果 preferredAddress 对应的 StreamServer 存在且活跃则返回，否则返回当前所有活跃的 StreamServer。</p>
<h6 id="4-received-IncomingDatagramMessage-msg"><a href="#4-received-IncomingDatagramMessage-msg" class="headerlink" title="(4) received(IncomingDatagramMessage msg)"></a>(4) received(IncomingDatagramMessage msg)</h6><p>根据消息类型得到协议并执行。</p>
<h6 id="5-发送数据"><a href="#5-发送数据" class="headerlink" title="(5) 发送数据"></a>(5) 发送数据</h6><p>send(StreamRequestMessage msg) 通过 StreamClient 发送 TCP 包。<br>send(OutgoingDatagramMessage msg) 向所有 datagramIO 发送 UDP 包。<br>broadcast(byte[] bytes) 向所有 datagramIO 广播发送数据。</p>
<h5 id="2-1-5-13-StreamClient"><a href="#2-1-5-13-StreamClient" class="headerlink" title="2.1.5.13 StreamClient"></a>2.1.5.13 StreamClient</h5><p>StreamClient 具体实现类为 AbstractStreamClient 以及其子类 StreamClientImpl。<br>在 Android 系统下使用的 Jetty 实现。在该类中具体的 http 协议处理由 HttpClient 实现，核心方法 sendRequest 用于创建请求并获取返回 response，请求及返回值通过 HttpContentExchange 封装，每一个 StreamRequestMessage 及其对应的 HttpContentExchange 通过 createCallable 方法封装为 Callable 对象，并将其压入 DefaultUpnpServiceConfiguration 中的 defaultExecutorService。在 call() 中调用 client.send(exchange) 发送 request 并获取 response。</p>
<h5 id="2-1-5-14-StreamServer"><a href="#2-1-5-14-StreamServer" class="headerlink" title="2.1.5.14 StreamServer"></a>2.1.5.14 StreamServer</h5><p>StreamServer 用来接收 HTTP 请求并进行处理。在 AndroidUpnpServiceConfiguration 中进行初始化：</p>
<pre><code>public StreamServer createStreamServer(NetworkAddressFactory networkAddressFactory) {
        // Use Jetty, start/stop a new shared instance of JettyServletContainer
        return new AsyncServletStreamServerImpl(
            new AsyncServletStreamServerConfigurationImpl(
                JettyServletContainer.INSTANCE,
                networkAddressFactory.getStreamListenPort()
            )
        );
    }
</code></pre><p>本质上是由 Jetty 实现的 servlet 容器。从 HttpServletRequest 中获取数据流并传递给 Router 的 received(UpnpStream stream) 进行处理。JettyServletContainer 使用了单例模式，其中定义 Server 的具体实现，并使用 synchronized 同步 Server 属性变更操作。</p>
<h5 id="2-1-5-15-ReceivingNotification"><a href="#2-1-5-15-ReceivingNotification" class="headerlink" title="2.1.5.15 ReceivingNotification"></a>2.1.5.15 ReceivingNotification</h5><p>处理接收到的 notification 消息。如 ALIVE，BYEBYE。当接收到 ALIVE 消息后，会在后台启动一个线程执行 RetrieveRemoteDescriptors 获取该设备的信息。</p>
<h5 id="2-1-5-16-RetrieveRemoteDescriptors"><a href="#2-1-5-16-RetrieveRemoteDescriptors" class="headerlink" title="2.1.5.16 RetrieveRemoteDescriptors"></a>2.1.5.16 RetrieveRemoteDescriptors</h5><p>用来主动获取远端介绍详情，并返回 RemoteService 加入到 Registry 中。</p>
<h5 id="额外补充-MulticastSocket多播协议"><a href="#额外补充-MulticastSocket多播协议" class="headerlink" title="额外补充 MulticastSocket多播协议"></a>额外补充 MulticastSocket多播协议</h5><p>前面说过设备开启之后 启动MulticastSocket多播协议，<br>先来复习一下网络通讯中的三种模式：</p>
<p>在当前网络通信中（TCP/IP也不例外）有三种通信模式：<strong>单播、广播、组播(又叫多播, 个人感觉叫多播描述的有点不恰当)</strong>，其中多播出现的时间最晚，但同时具备单播和广播的优点，最具有发展前景。<br>通信方式分类：<br>    1.单播：单台主机与单台主机之间的通信；<br>    2.广播：单台主机与网络中所有主机的通信；<br>    3.组播：单台主机与选定的一组主机的通信；</p>
<h6 id="单播："><a href="#单播：" class="headerlink" title="单播："></a>单播：</h6><blockquote>
<pre><code> 单播是网络通信中最常见的，网络节点之间的通信 就好像是人们之间的对话一样。如果一个人对另外一个人说话，
 那么用网络技术的术语来描述就是“单播”，此时信息的接收和传递只在两个节点之间进行。
 1. 单播的优点：
     (1)服务器以及响应客户端的请求；
     (2)服务器能针对每个客户端的不同请求发送不同的响应，容易显示个性化服务；
 2. 单播的缺点：
     (1)服务器针对每个客户机发送数据流，服务器流量＝客户机数量×客户机流量；在客户数量大、每个客户机流量大的流媒体应用中服务器不堪重负；
 3. 应用场景：
    单播在网络中得到了广泛的应用，网络上绝大部分的数据都 是以单播的形式传输的。例如：收发电子邮件、游览网页时，必须与邮件服务器、
    服务器建立连接，此时使用的就是单播通信方式；
</code></pre></blockquote>
<h6 id="广播："><a href="#广播：" class="headerlink" title="广播："></a>广播：</h6><blockquote>
<pre><code>“广播”可以比方为：一个人通过广播喇叭对在场的全体说话(他才不管你是否乐意听)。换句话说: 广播是一台主机对某一个网络上的所有主机发送数据报包。
这个网络可能是网络，也可能时子网，还有可能是所有子网。
广播有两类：本地广播和定向广播：
        定向广播：将数据报包发送到本网络之外的特定网络的所有主机，然而，由于互联网上的大部分路由器都不转发定向广播消息，所以这里不深入介绍了
        本地广播：将数据报包发送到本地网络的所有主机，IPv4的本地广播地址为“255.255.255.255”，路由器不会转发此广播；
1.广播的优点：
   (1)通信的效率高，信息一下子就可以传递到某一个网络上的所有主机。
   (2)由于服务器不用向每个客户端单独发送数据，所以服务器流量比较负载低；
2.广播的缺点：
   (1)非常占用网络的带宽；
   (2)缺乏针对性,也不管主机是否真的需要接收该数据, 就强制的接收数据；
3.应用场景：
   (1)有线电视就是典型的广播型网络
</code></pre></blockquote>
<h6 id="组播："><a href="#组播：" class="headerlink" title="组播："></a>组播：</h6><blockquote>
<pre><code> ”组播“可以比方为：你对着大街喊：”是男人的来一下，一人发一百块”，那么男的过来，女就不会过来,因为没有钱发她不理你(组播：其中所有的男生就是一个组)，
 换句话说: 组播是一台主机向指定的一组主机发送数据报包，因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率 极低，是不可取  
 的；如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的，又会占用网络带宽。采用组播方式，既可以 实现一次传送所
 有目标节点的数据，也可以达到只对特定对象传送数据的目的。
 IP网络的组播一般通过组播IP地址来实现。组播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。
 1.组播的优点：
(1)具备广播所具备的所有优点；
(2)与单播相比，提供了发送数据报包的效率，与广播相比，减少了网络流量；
 2.组播的缺点：
(1)与单播协议相比没有纠错机制，发生丢包错包后难以弥补，但可以通过一定的容错机制和QOS加以弥补；
</code></pre></blockquote>
<p>没有代码bb个毛线，来实现一下：</p>
<h6 id="UDP单播的例子"><a href="#UDP单播的例子" class="headerlink" title="UDP单播的例子"></a>UDP单播的例子</h6><pre><code>

// 客户端  
public class ClientTest  
{  
    private static final int MAXRECEIVED = 255;  

    public static void main(String[] args) throws IOException  
    {  
        byte[] msg = new String(&quot;connect test successfully!!!&quot;).getBytes();  

        DatagramSocket client = new DatagramSocket();  

        InetAddress inetAddr = InetAddress.getLocalHost();  
        SocketAddress socketAddr = new InetSocketAddress(inetAddr, 8888);  

        DatagramPacket sendPacket = new DatagramPacket(msg, msg.length,  
                socketAddr);  

        client.send(sendPacket);  

        client.close();  
    }  
}  



//服务端  
public class ServerTest  
{  
    private static final int MAXREV = 255;  

    public static void main(String[] args) throws IOException  
    {  
        DatagramSocket server = new DatagramSocket(8888);  
        DatagramPacket recvPacket = new DatagramPacket(new byte[MAXREV], MAXREV);  

        while (true)  
        {  
            server.receive(recvPacket);  

            byte[] receiveMsg = Arrays.copyOfRange(recvPacket.getData(),  
                    recvPacket.getOffset(),  
                    recvPacket.getOffset() + recvPacket.getLength());  

            System.out.println(&quot;Handing at client &quot;  
                    + recvPacket.getAddress().getHostName() + &quot; ip &quot;  
                    + recvPacket.getAddress().getHostAddress());  

            System.out.println(&quot;Server Receive Data:&quot; + new String(receiveMsg));  

            server.send(recvPacket);  

        }  

    }  
}
</code></pre><h6 id="UDP广播的例子"><a href="#UDP广播的例子" class="headerlink" title="UDP广播的例子"></a>UDP广播的例子</h6><pre><code>//客户端  
public class BroadcastSender  
{  
    public static void main(String[] args) throws IOException  
    {  
        byte[] msg = new String(&quot;connection successfully!!!&quot;).getBytes();  
        /* 
         * 在Java UDP中单播与广播的代码是相同的,要实现具有广播功能的程序只需要使用广播地址即可, 例如：这里使用了本地的广播地址 
         */  
        InetAddress inetAddr = InetAddress.getByName(&quot;255.255.255.255&quot;);  
        DatagramSocket client = new DatagramSocket();  

        DatagramPacket sendPack = new DatagramPacket(msg, msg.length, inetAddr,  
                8888);  

        client.send(sendPack);  
        System.out.println(&quot;Client send msg complete&quot;);  
        client.close();  
    }  
}  


//服务端  
public class BroadcastReceive  
{  
    public static void main(String[] args) throws IOException  
    {  

        DatagramPacket receive = new DatagramPacket(new byte[1024], 1024);  
        DatagramSocket server = new DatagramSocket(8888);  

        System.out.println(&quot;---------------------------------&quot;);  
        System.out.println(&quot;Server current start......&quot;);  
        System.out.println(&quot;---------------------------------&quot;);  

        while (true)  
        {  
            server.receive(receive);  

            byte[] recvByte = Arrays.copyOfRange(receive.getData(), 0,  
                    receive.getLength());  

            System.out.println(&quot;Server receive msg:&quot; + new String(recvByte));  
        }  

    }  
}
</code></pre><h6 id="UDP组播的例子"><a href="#UDP组播的例子" class="headerlink" title="UDP组播的例子"></a>UDP组播的例子</h6><pre><code>
//客户端  
public class MulticastSender  
{  
    public static void main(String[] args) throws IOException  
    {  
        int port = 8888;  
        byte[] msg = &quot;Connection successfully!!!&quot;.getBytes();  

        InetAddress inetRemoteAddr = InetAddress.getByName(&quot;224.0.0.5&quot;);  

        /* 
         * Java UDP组播应用程序主要通过MulticastSocket实例进行通信,它是DatagramSocket的是一个子类, 
         * 其中包含了一些额外的可以控制多播的属性. 
         *  
         * 注意： 
         *  
         * 多播数据报包实际上可以通过DatagramSocket发送,只需要简单地指定一个多播地址。 
         * 我们这里使用MulticastSocket,是因为它具有DatagramSocket没有的能力 
         */  
        MulticastSocket client = new MulticastSocket();  

        DatagramPacket sendPack = new DatagramPacket(msg, msg.length,  
                inetRemoteAddr, port);  

        client.send(sendPack);  

        System.out.println(&quot;Client send msg complete&quot;);  

        client.close();  

    }  
}  



//服务端  
public class MulticastReceive  
{  
    public static void main(String[] args) throws IOException  
    {  
        InetAddress inetRemoteAddr = InetAddress.getByName(&quot;224.0.0.5&quot;);  

        DatagramPacket recvPack = new DatagramPacket(new byte[1024], 1024);  

        MulticastSocket server = new MulticastSocket(8888);  

        /* 
         * 如果是发送数据报包,可以不加入多播组; 如果是接收数据报包,必须加入多播组; 这里是接收数据报包,所以必须加入多播组; 
         */  
        server.joinGroup(inetRemoteAddr);  

        System.out.println(&quot;---------------------------------&quot;);  
        System.out.println(&quot;Server current start......&quot;);  
        System.out.println(&quot;---------------------------------&quot;);  

        while (true)  
        {  
            server.receive(recvPack);  

            byte[] recvByte = Arrays.copyOfRange(recvPack.getData(), 0,  
                    recvPack.getLength());  

            System.out.println(&quot;Server receive msg:&quot; + new String(recvByte));  
        }  

    }  
}
</code></pre>
      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Ace
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://www.azhangbing.com/2017/10/25/Cling介绍/" title="Android投屏,同屏库Cling源码使用和解析">http://www.azhangbing.com/2017/10/25/Cling介绍/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/24/Java-到底是值传递还是引用传递/" rel="next" title="Java 到底是值传递还是引用传递?">
                <i class="fa fa-chevron-left"></i> Java 到底是值传递还是引用传递?
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/06/Java虚拟机类加载机制/" rel="prev" title="Java虚拟机类加载机制">
                Java虚拟机类加载机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="Ace" />
            
              <p class="site-author-name" itemprop="name">Ace</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">Kategorien</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">Tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="mailto:psel1991@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-简单使用"><span class="nav-number">1.</span> <span class="nav-text">1. 简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-源码解析"><span class="nav-number">2.</span> <span class="nav-text">2.源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-总体设计"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 总体设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-概述"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-使用场景"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-设备发现及控制流程"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 设备发现及控制流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-类关系图"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 类关系图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-类功能详细介绍"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.5 类功能详细介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-1-ControlPoint"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">2.1.5.1 ControlPoint</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-查找"><span class="nav-number">2.1.5.1.1.</span> <span class="nav-text">(1) 查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-执行控制指令"><span class="nav-number">2.1.5.1.2.</span> <span class="nav-text">(2) 执行控制指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-执行事件订阅指令"><span class="nav-number">2.1.5.1.3.</span> <span class="nav-text">(3) 执行事件订阅指令</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-2-ProtocolFactory"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">2.1.5.2 ProtocolFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-处理接收到的报文"><span class="nav-number">2.1.5.2.1.</span> <span class="nav-text">(1) 处理接收到的报文</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-组装发送的报文"><span class="nav-number">2.1.5.2.2.</span> <span class="nav-text">(2) 组装发送的报文</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-3-Registry"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">2.1.5.3 Registry</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-4-RegistryListener"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">2.1.5.4 RegistryListener</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-5-Resource"><span class="nav-number">2.1.5.5.</span> <span class="nav-text">2.1.5.5 Resource</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-6-RegistryItem"><span class="nav-number">2.1.5.6.</span> <span class="nav-text">2.1.5.6 RegistryItem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-7-RegistryItems"><span class="nav-number">2.1.5.7.</span> <span class="nav-text">2.1.5.7 RegistryItems</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-8-LocalItems"><span class="nav-number">2.1.5.8.</span> <span class="nav-text">2.1.5.8 LocalItems</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-9-RemoteItems"><span class="nav-number">2.1.5.9.</span> <span class="nav-text">2.1.5.9 RemoteItems</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-10-xpirationDetails"><span class="nav-number">2.1.5.10.</span> <span class="nav-text">2.1.5.10 xpirationDetails</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-11-RegistryMaintainer"><span class="nav-number">2.1.5.11.</span> <span class="nav-text">2.1.5.11 RegistryMaintainer</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-判断过期的-item，并从-resourceItems-中移除；"><span class="nav-number">2.1.5.11.1.</span> <span class="nav-text">(1) 判断过期的 item，并从 resourceItems 中移除；</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-遍历-resourceItems，对其中的每个-Resource-调用其-maintain-方法；"><span class="nav-number">2.1.5.11.2.</span> <span class="nav-text">(2) 遍历 resourceItems，对其中的每个 Resource 调用其 maintain() 方法；</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-remoteItems-maintain-对-remote-进行维护；"><span class="nav-number">2.1.5.11.3.</span> <span class="nav-text">(3) remoteItems.maintain() 对 remote 进行维护；</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-localItems-maintain-对-local-进行维护；"><span class="nav-number">2.1.5.11.4.</span> <span class="nav-text">(4) localItems.maintain() 对 local 进行维护；</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-runPendingExecutions-执行异步任务。"><span class="nav-number">2.1.5.11.5.</span> <span class="nav-text">(5) runPendingExecutions 执行异步任务。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-12-Router"><span class="nav-number">2.1.5.12.</span> <span class="nav-text">2.1.5.12 Router</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-enable"><span class="nav-number">2.1.5.12.1.</span> <span class="nav-text">(1) enable()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-disable"><span class="nav-number">2.1.5.12.2.</span> <span class="nav-text">(2) disable()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-getActiveStreamServers-InetAddress-preferredAddress"><span class="nav-number">2.1.5.12.3.</span> <span class="nav-text">(3) getActiveStreamServers(InetAddress preferredAddress)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-received-IncomingDatagramMessage-msg"><span class="nav-number">2.1.5.12.4.</span> <span class="nav-text">(4) received(IncomingDatagramMessage msg)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-发送数据"><span class="nav-number">2.1.5.12.5.</span> <span class="nav-text">(5) 发送数据</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-13-StreamClient"><span class="nav-number">2.1.5.13.</span> <span class="nav-text">2.1.5.13 StreamClient</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-14-StreamServer"><span class="nav-number">2.1.5.14.</span> <span class="nav-text">2.1.5.14 StreamServer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-15-ReceivingNotification"><span class="nav-number">2.1.5.15.</span> <span class="nav-text">2.1.5.15 ReceivingNotification</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-16-RetrieveRemoteDescriptors"><span class="nav-number">2.1.5.16.</span> <span class="nav-text">2.1.5.16 RetrieveRemoteDescriptors</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#额外补充-MulticastSocket多播协议"><span class="nav-number">2.1.5.17.</span> <span class="nav-text">额外补充 MulticastSocket多播协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#单播："><span class="nav-number">2.1.5.17.1.</span> <span class="nav-text">单播：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#广播："><span class="nav-number">2.1.5.17.2.</span> <span class="nav-text">广播：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#组播："><span class="nav-number">2.1.5.17.3.</span> <span class="nav-text">组播：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#UDP单播的例子"><span class="nav-number">2.1.5.17.4.</span> <span class="nav-text">UDP单播的例子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#UDP广播的例子"><span class="nav-number">2.1.5.17.5.</span> <span class="nav-text">UDP广播的例子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#UDP组播的例子"><span class="nav-number">2.1.5.17.6.</span> <span class="nav-text">UDP组播的例子</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ace</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
