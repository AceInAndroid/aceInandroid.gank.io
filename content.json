{"meta":{"title":"Zhangbing's Blog","subtitle":null,"description":"Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable","author":"Zhangbing","url":"http://zhangbing.cc","root":"/"},"pages":[{"title":"404","date":"2019-03-01T01:49:50.000Z","updated":"2019-03-01T01:49:50.255Z","comments":true,"path":"404/index.html","permalink":"http://zhangbing.cc/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-03-01T01:49:06.000Z","updated":"2019-03-01T01:49:06.597Z","comments":true,"path":"about/index.html","permalink":"http://zhangbing.cc/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-07T02:18:01.655Z","updated":"2019-03-07T02:18:01.650Z","comments":false,"path":"categories/index.html","permalink":"http://zhangbing.cc/categories/index.html","excerpt":"","text":"title: categories date: 2019-03-07 10:16:23"},{"title":"home","date":"2019-03-01T03:15:59.000Z","updated":"2019-03-01T03:15:59.093Z","comments":true,"path":"home/index.html","permalink":"http://zhangbing.cc/home/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-08T09:23:44.000Z","updated":"2019-03-08T09:23:44.547Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhangbing.cc/tags/index-1.html","excerpt":"","text":""},{"title":"","date":"2019-03-08T09:24:06.639Z","updated":"2019-03-07T02:18:21.348Z","comments":false,"path":"tags/index.html","permalink":"http://zhangbing.cc/tags/index.html","excerpt":"","text":"title: tags date: 2019-03-01 09:48:50"}],"posts":[{"title":"设计模式（一）——设计模式概述","slug":"designpattern-1552620493098","date":"2019-03-15T03:28:13.000Z","updated":"2019-03-15T03:29:20.632Z","comments":true,"path":"2019/03/15/designpattern-1552620493098/","link":"","permalink":"http://zhangbing.cc/2019/03/15/designpattern-1552620493098/","excerpt":"","text":"设计模式（一）——设计模式概述在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案。可以认为是一种最佳实践，因为他是无数软件开发人员经过长时间的实践总结出来的。 提到设计模式不得不提《设计模式：可复用面向对象软件的基础》（Design Patterns – Elements of Reusable Object-Oriented Software） 一书。这本书由著名的四人帮——GoF(Gang of Four)编写，其中总结了23种设计模式，并将他们分成几个大类。 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）合成复用原则是尽量使用合成/聚合的方式，而不是使用继承。 其中前四种也是面向对象的四个基本原则。 设计模式分类设计模式分为三种类型，共23种。 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 23种设计模式简单介绍按字典序排列简介如下。 Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Chain of Responsibility（责任链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 Composite（组合模式）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 Decorator（装饰模式）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 Facade（外观模式）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 Factory Method（工厂模式）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。 Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。 Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 Mediator（中介模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。 Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。 State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 23种设计模式之间的关系图片来自网络，侵删","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhangbing.cc/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhangbing.cc/tags/设计模式/"}]},{"title":"HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！","slug":"ConcurrentHashMap","date":"2019-03-14T03:10:16.000Z","updated":"2019-03-14T05:05:51.024Z","comments":true,"path":"2019/03/14/ConcurrentHashMap/","link":"","permalink":"http://zhangbing.cc/2019/03/14/ConcurrentHashMap/","excerpt":"前言Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。 本篇主要想讨论 ConcurrentHashMap 这样一个并发容器，在正式开始之前我觉得有必要谈谈 HashMap，没有它就不会有后面的 ConcurrentHashMap。 HashMap众所周知 HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。 Base 1.71.7 中的数据结构图：","text":"前言Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。 本篇主要想讨论 ConcurrentHashMap 这样一个并发容器，在正式开始之前我觉得有必要谈谈 HashMap，没有它就不会有后面的 ConcurrentHashMap。 HashMap众所周知 HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。 Base 1.71.7 中的数据结构图： 先来看看 1.7 中的实现。 这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？ 初始化桶大小，因为底层是数组，所以这是数组默认的大小。 桶最大值。 默认的负载因子（0.75） table 真正存放数据的数组。 Map 存放数量的大小。 桶大小，可在初始化时显式指定。 负载因子，可在初始化时显式指定。 重点解释下负载因子： 由于给定的 HashMap 的容量大小是固定的，比如默认初始化： 123456789101112131415161718public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init();&#125; 给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。 因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。 根据代码可以看到其实真正存放数据的是 transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; 这个数组，那么它又是如何定义的呢？ Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出： key 就是写入时的键。 value 自然就是值。 开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。 hash 存放的是当前 key 的 hashcode。 知晓了基本结构，那来看看其中重要的写入、获取函数： put 方法12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 判断当前数组是否需要初始化。 如果 key 为空，则 put 一个空值进去。 根据 key 计算出 hashcode。 根据计算出的 hashcode 定位出所在桶。 如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。 如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。 123456789101112131415void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 当调用 addEntry 写入 Entry 时需要判断是否需要扩容。 如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。 而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。 get 方法再来看看 get 函数： 123456789101112131415161718192021222324public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; 首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。 判断该位置是否为链表。 不是链表就根据 key、key 的 hashcode 是否相等来返回值。 为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。 啥都没取到就直接返回 null 。 Base 1.8不知道 1.7 的实现大家看出需要优化的点没有？ 其实一个很明显的地方就是： 当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 O(N)。 因此 1.8 中重点优化了这个查询效率。 1.8 HashMap 结构图： 先来看看几个核心的成员变量： 12345678910111213141516171819202122232425262728static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;transient Node&lt;K,V&gt;[] table;/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** * The number of key-value mappings contained in this map. */transient int size; 和 1.7 大体上都差不多，还是有几个重要的区别： TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。 HashEntry 修改为 Node。 Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 key value hashcode next 等数据。 再来看看核心方法。 put 方法 看似要比 1.7 的复杂，我们一步步拆解： 判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。 根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。 如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。 如果当前桶为红黑树，那就要按照红黑树的方式写入数据。 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。 接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。 如果在遍历过程中找到 key 相同时直接退出遍历。 如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。 最后判断是否需要进行扩容。 get 方法12345678910111213141516171819202122232425public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; get 方法看起来就要简单许多了。 首先将 key hash 之后取得所定位的桶。 如果桶为空则直接返回 null 。 否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。 如果第一个不匹配，则判断它的下一个是红黑树还是链表。 红黑树就按照树的查找方式返回值。 不然就按照链表的方式遍历匹配返回值。 从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 O(logn)。 但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。 123456789final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();for (int i = 0; i &lt; 1000; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; map.put(UUID.randomUUID().toString(), \"\"); &#125; &#125;).start();&#125; 但是为什么呢？简单分析下。 看过上文的还记得在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。 如下图： 遍历方式还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种： 123456789101112Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator(); while (entryIterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; next = entryIterator.next(); System.out.println(\"key=\" + next.getKey() + \" value=\" + next.getValue()); &#125; Iterator&lt;String&gt; iterator = map.keySet().iterator(); while (iterator.hasNext())&#123; String key = iterator.next(); System.out.println(\"key=\" + key + \" value=\" + map.get(key)); &#125; 强烈建议使用第一种 EntrySet 进行遍历。 第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。 简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。 因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 java.util.concurrent 包下，专门用于解决并发问题。 坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析。 ConcurrentHashMapConcurrentHashMap 同样也分为 1.7 、1.8 版，两者在实现上略有不同。 Base 1.7先来看看 1.7 的实现，下面是他的结构图： 如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。 它的核心成员变量： 1234567/** * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。 */final Segment&lt;K,V&gt;[] segments;transient Set&lt;K&gt; keySet;transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下： 12345678910111213141516 static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶 transient volatile HashEntry&lt;K,V&gt;[] table; transient int count; transient int modCount; transient int threshold; final float loadFactor; &#125; 看看其中 HashEntry 的组成： 和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。 原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。 下面也来看看核心的 put get 方法。 put 方法1234567891011public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false);&#125; 首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。 12345678910111213141516171819202122232425262728293031323334353637383940414243final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。 首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。 尝试自旋获取锁。 如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。 再结合图看看 put 的流程。 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。 最后会解除在 1 中所获取当前 Segment 的锁。 get 方法1234567891011121314151617public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; get 逻辑比较简单： 只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。 由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。 ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。 Base 1.81.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。 那就是查询遍历链表效率太低。 因此 1.8 做了一些数据结构上的调整。 首先来看下底层的组成结构： 看起来是不是和 1.8 HashMap 结构类似？ 其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。 也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。 其中的 val next 都用了 volatile 修饰，保证了可见性。 put 方法重点来看看 put 函数： 根据 key 计算出 hashcode 。 判断是否需要进行初始化。 f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 如果都不满足，则利用 synchronized 锁写入数据。 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 get 方法 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。 如果是红黑树那就按照树的方式获取值。 就不满足那就按照链表的方式遍历获取值。 1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。 总结看完了整个 HashMap 和 ConcurrentHashMap 在 1.7 和 1.8 中不同的实现方式相信大家对他们的理解应该会更加到位。 其实这块也是面试的重点内容，通常的套路是： 谈谈你理解的 HashMap，讲讲其中的 get put 过程。 1.8 做了什么优化？ 是线程安全的嘛？ 不安全会导致哪些问题？ 如何解决？有没有线程安全的并发容器？ ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？ 这一串问题相信大家仔细看完都能怼回面试官。","categories":[{"name":"Java 进阶","slug":"Java-进阶","permalink":"http://zhangbing.cc/categories/Java-进阶/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhangbing.cc/tags/Java/"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"http://zhangbing.cc/tags/ConcurrentHashMap/"},{"name":"HashMap","slug":"HashMap","permalink":"http://zhangbing.cc/tags/HashMap/"},{"name":"concurrent","slug":"concurrent","permalink":"http://zhangbing.cc/tags/concurrent/"}]},{"title":"#系统源码解读:深入理解DecorView与ViewRootImpl","slug":"DecorViewAndViewRootImpl-1552480772465","date":"2019-03-13T12:39:32.000Z","updated":"2019-03-13T12:42:38.180Z","comments":true,"path":"2019/03/13/DecorViewAndViewRootImpl-1552480772465/","link":"","permalink":"http://zhangbing.cc/2019/03/13/DecorViewAndViewRootImpl-1552480772465/","excerpt":"系统源码解读:深入理解DecorView与ViewRootImpl前言对于Android开发者来说，View无疑是开发中经常接触的，包括它的事件分发机制、测量、布局、绘制流程等，如果要自定义一个View，那么应该对以上流程有所了解、研究。本系列文章将会为大家带来View的工作流程详细解析。在深入接触View的测量、布局、绘制这三个流程之前，我们从Activity入手，看看从Activity创建后到View的正式工作之前，所要经历的步骤。以下源码均取自Android API 21。","text":"系统源码解读:深入理解DecorView与ViewRootImpl前言对于Android开发者来说，View无疑是开发中经常接触的，包括它的事件分发机制、测量、布局、绘制流程等，如果要自定义一个View，那么应该对以上流程有所了解、研究。本系列文章将会为大家带来View的工作流程详细解析。在深入接触View的测量、布局、绘制这三个流程之前，我们从Activity入手，看看从Activity创建后到View的正式工作之前，所要经历的步骤。以下源码均取自Android API 21。 setContentView从setContentView说起一般地，我们在Activity中，会在onCreate()方法中写下这样一句： 1setContentView(R.layout.main); 显然，这是为activity设置一个我们定义好的main.xml布局，我们跟踪一下源码，看看这个方法是怎样做的，Activity的setContentView(): 12345678public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); //调用getWindow方法，返回mWindow initWindowDecorActionBar();&#125;...public Window getWindow() &#123; return mWindow;&#125; 从上面看出，里面调用了mWindow的setContentView方法，那么这个“mWindow”是何方神圣呢？尝试追踪一下源码，发现mWindow是Window类型的，但是它是一个抽象类，setContentView也是抽象方法，所以我们要找到Window类的实现类才行。我们在Activity中查找一下mWindow在哪里被赋值了，可以发现它在Activity#attach方法中有如下实现： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; ... mWindow = new PhoneWindow(this, window);//创建一个Window对象 mWindow.setWindowControllerCallback(this); mWindow.setCallback(this);//设置回调，向Activity分发点击或状态改变等事件 mWindow.setOnWindowDismissedCallback(this); ... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//给Window设置WindowManager对象... &#125; 我们只看关键部分，这里实例化了PhoneWindow类，由此得知，PhoneWindow是Window的实现类，那么我们在PhoneWindow类里面找到它的setContentView方法，看看它又实现了什么，PhoneWindow的setContentView: 1234567891011121314151617181920212223@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; // 1 installDecor();//mContentParent为空，创建一个DecroView &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews();//mContentParent不为空，删除其中的View &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); //为mContentParent添加子View,即Activity中设置的布局文件 &#125; final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged();//回调通知，内容改变 &#125;&#125; 首先判断了mContentParent是否为null，如果为空则执行installDecor()方法，那么这个mContentParent又是什么呢？我们看一下它的注释： 123// This is the view in which the window contents are placed. It is either// mDecor itself, or a child of mDecor where the contents go.private ViewGroup mContentParent; 它是一个ViewGroup类型，结合2的代码处得知,这个mContentParent是我们设置的布局(即main.xml)的父布局。注释还提到了，这个mContentParent是mDecor本身或者是mDecor的一个子元素，这句话什么意思呢？这里先留一个疑问，下面会解释。 这里先梳理一下以上的内容：通过上面的流程我们大致可以了解先在PhoneWindow中创建了一个DecroView，其中创建的过程中可能根据Theme不同，加载不同的布局格式，例如有没有Title，或有没有ActionBar等，然后再向mContentParent中加入子View,即Activity中设置的布局。到此位置，视图一层层嵌套添加上了。 创建DecorView接着上面提到的installDecor()方法，我们看看它的源码，PhoneWindow#installDecor: 123456789101112131415private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); // 1 生成DecorView mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); // 2 为DecorView设置布局格式，并返回mContentParent ... &#125; &#125;&#125; 首先，会执行1的代码，调用PhoneWindow#generateDecor方法： 123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 可以看出，这里实例化了DecorView，而DecorView则是PhoneWindow类的一个内部类，继承于FrameLayout，由此可知它也是一个ViewGroup。那么，DecroView到底充当了什么样的角色呢？其实，DecorView是整个ViewTree的最顶层View，它是一个FrameLayout布局，代表了整个应用的界面。在该布局下面，有标题view和内容view这两个子元素，而内容view则是上面提到的mContentParent。 我们接着看2处的代码，PhoneWindow#generateLayout方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. // 从主题文件中获取样式信息 TypedArray a = getWindowStyle(); ... if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don't allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; if(...)&#123; ... &#125; // Inflate the window decor. // 根据主题样式，加载窗口布局 int layoutResource; int features = getLocalFeatures(); // System.out.println(\"Features: 0x\" + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; &#125; else if(...)&#123; ... &#125; View in = mLayoutInflater.inflate(layoutResource, null); //加载layoutResource decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); //往DecorView中添加子View，即mContentParent mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); // 这里获取的就是mContentParent @android:id/content if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) &#123; ProgressBar progress = getCircularProgressBar(false); if (progress != null) &#123; progress.setIndeterminate(true); &#125; &#125; if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; registerSwipeCallbacks(); &#125; // Remaining setup -- of background and title -- that only applies // to top-level windows. ... return contentParent; &#125; 由以上代码可以看出，该方法还是做了相当多的工作的，首先根据设置的主题样式来设置DecorView的风格，比如说有没有titlebar之类的，接着为DecorView添加子View，而这里的子View则是上面提到的mContentParent，如果上面设置了FEATURE_NO_ACTIONBAR，那么DecorView就只有mContentParent一个子View，这也解释了上面的疑问：mContentParent是DecorView本身或者是DecorView的一个子元素。用一幅图来表示DecorView的结构如下： 小结： DecorView是顶级View，内部有titlebar和contentParent两个子元素，contentParent的id是content，而我们设置的main.xml布局则是contentParent里面的一个子元素。 在DecorView创建完毕后，让我们回到PhoneWindow#setContentView方法，直接看2处代码： mLayoutInflater.inflate(layoutResID, mContentParent);这里加载了我们设置的main.xml布局文件，并且设置mContentParent为main.xml的父布局，至于它怎么加载的，这里就不展开来说了。 到目前为止，通过setContentView方法，创建了DecorView和加载了我们提供的布局，但是这时，我们的View还是不可见的，因为我们仅仅是加载了布局，并没有对View进行任何的测量、布局、绘制工作。在View进行测量流程之前，还要进行一个步骤，那就是把DecorView添加至window中，然后经过一系列过程触发ViewRootImpl#performTraversals方法，在该方法内部会正式开始测量、布局、绘制这三大流程。至于该一系列过程是怎样的，因为涉及到了很多机制，这里简单说明一下： 将DecorView添加至Window每一个Activity组件都有一个关联的Window对象，用来描述一个应用程序窗口。每一个应用程序窗口内部又包含有一个View对象，用来描述应用程序窗口的视图。上文分析了创建DecorView的过程，现在则要把DecorView添加到Window对象中。而要了解这个过程，我们首先要简单先了解一下Activity的创建过程：首先，在ActivityThread#handleLaunchActivity中启动Activity，在这里面会调用到Activity#onCreate方法，从而完成上面所述的DecorView创建动作，当onCreate()方法执行完毕，在handleLaunchActivity方法会继续调用到ActivityThread#handleResumeActivity方法，我们看看这个方法的源码： 12345678910111213141516171819202122232425final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123; //... ActivityClientRecord r = performResumeActivity(token, clearHide); // 这里会调用到onResume()方法 if (r != null) &#123; final Activity a = r.activity; //... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); // 获得window对象 View decor = r.window.getDecorView(); // 获得DecorView对象 decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); // 获得windowManager对象 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); // 调用addView方法 &#125; //... &#125; &#125;&#125; 在该方法内部，获取该activity所关联的window对象，DecorView对象，以及WindowManager对象，而WindowManager是抽象类，它的实现类是WindowManagerImpl，所以后面调用的是WindowManagerImpl#addView方法，我们看看源码： 12345678public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); ... @Override public void addView(View view, ViewGroup.LayoutParams params) &#123; mGlobal.addView(view, params, mDisplay, mParentWindow); &#125;&#125; 接着调用了mGlobal的成员函数，而mGlobal则是WindowManagerGlobal的一个实例，那么我们接着看WindowManagerGlobal#addView方法： 123456789101112131415161718192021222324252627282930313233public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ... root = new ViewRootImpl(view.getContext(), display); // 1 view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); // 2 &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; &#125; 先看1号代码处，实例化了ViewRootImpl类，接着，在2号代码处，调用ViewRootImpl#setView方法，并把DecorView作为参数传递进去，在这个方法内部，会通过跨进程的方式向WMS（WindowManagerService）发起一个调用，从而将DecorView最终添加到Window上，在这个过程中，ViewRootImpl、DecorView和WMS会彼此关联，至于详细过程这里不展开来说了。最后通过WMS调用ViewRootImpl#performTraverals方法,然后依照下图流程层层调用，完成绘制，最终界面才显示出来,下偏文章讲View的绘制.","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangbing.cc/categories/Android/"}],"tags":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://zhangbing.cc/tags/Android源码解析/"},{"name":"DecorView","slug":"DecorView","permalink":"http://zhangbing.cc/tags/DecorView/"},{"name":"ViewRootImpl","slug":"ViewRootImpl","permalink":"http://zhangbing.cc/tags/ViewRootImpl/"}]},{"title":"为什么要有Java内存模型?","slug":"WhyhasJMMexit-1552272874543","date":"2019-03-11T02:54:34.000Z","updated":"2019-03-11T02:56:55.056Z","comments":true,"path":"2019/03/11/WhyhasJMMexit-1552272874543/","link":"","permalink":"http://zhangbing.cc/2019/03/11/WhyhasJMMexit-1552272874543/","excerpt":"","text":"为什么要有Java内存模型?Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。 网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。 为什么要有内存模型在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。 内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。 CPU和缓存一致性我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。 刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。 这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。 可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。 所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。 那么，程序的执行过程就变成了： 当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。 而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。 按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。 这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。 那么，在有了多级缓存之后，程序的执行就变成了： 当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。 随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。 单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。 公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。 单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。 多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。 还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。 随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。 单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。 单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。 多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。 在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。 如果这家公司的命令都是串行下发的话，那么就没有任何问题。 如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。 如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。 比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。 处理器优化和指令重排上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。 除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。 可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。 关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。 并发编程的问题前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。 其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。 这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性： 原子性:指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。 可见性:指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性:即程序执行的顺序按照代码的先后顺序执行。 有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。 什么是内存模型前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？ 最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。 所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。 内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。 什么是Java内存模型前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。 我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。 提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf） Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。 这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。 所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。 Java内存模型的实现了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。 在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。 本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证: 原子性在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。这两个字节码，在Java中对应的关键字就是synchronized。 因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。 可见性Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。 Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。 除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。 有序性在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别： volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。 好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。 但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。 总结在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。 可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbing.cc/categories/Java/"}],"tags":[{"name":"Java内存模型","slug":"Java内存模型","permalink":"http://zhangbing.cc/tags/Java内存模型/"}]},{"title":"JVM内存结构、 Java内存模型 以及 Java对象模型","slug":"JVMModel-1552035735257","date":"2019-03-08T09:02:15.000Z","updated":"2019-03-08T09:26:50.837Z","comments":true,"path":"2019/03/08/JVMModel-1552035735257/","link":"","permalink":"http://zhangbing.cc/2019/03/08/JVMModel-1552035735257/","excerpt":"","text":"JVM内存结构、 Java内存模型 以及 Java对象模型JVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。 可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。 一、JVM内存结构我们都知道，Java代码是要运行在虚拟机上的，Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故Java运行时内存结构，也就是指Java虚拟机的运行时内存结构。而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下： 1.JVM简介1.1线程私有区：这部分是线程独享 程序计数器：记录正在执行的虚拟机字节码的地址,行号；虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；本地方法栈：虚拟机的Native方法执行的内存区； 1.2线程共享区：Java堆：对象分配内存的区域；方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。 对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。 2. JVM结构详解运行时内存分为五大块区域（常量池属于方法区，算作一块区域），前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java内存总体结构图如下： 2.1 程序计数器PC程序计数器PC，当前线程所执行的字节码行号指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）。 从上面的介绍中我们知道程序计数器主要有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 2.2 虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。 虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)执行的同时都会创建一个栈帧结构，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。 2.2.1 栈帧(Stack Frame)结构 栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机栈的栈元素。见上图， 栈帧包括： 局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位,局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double),String引用类型，对象引用(reference类型)和returnAddress类型（它指向了一条字节码指令的地址） ,局部变量存储在局部变量表中，随着线程而生，线程而灭。并且线程间数据不共享。 操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配 动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。 前面的解析过程其实是静态解析； 对于运行期转化为直接引用，称为动态解析。 方法返回地址 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。 额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。 栈帧工作流程: 当Java应用程序调用函数调用时，会在调用堆栈上分配栈帧。栈帧包含调用方法的参数，其本地参数以及方法的返回地址。返回地址表示执行点，程序执行将在调用方法返回后继续执行。如果没有新栈帧的空间，则由Java虚拟机（JVM）抛出StackOverflowError。 可能耗尽Java应用程序堆栈的最常见情况是递归。在递归中，方法在执行期间调用自身。递归被认为是一种强大的通用编程技术，但必须谨慎使用，以避免StackOverflowError。 示例StackOverflowError： StackOverflowErrorExample.java：123456789101112131415public class StackOverflowErrorExample &#123; public static void recursivePrint(int num) &#123; System.out.println(\"Number: \" + num); if(num == 0) return; else recursivePrint(++num); &#125; public static void main(String[] args) &#123; StackOverflowErrorExample.recursivePrint(1); &#125;&#125; 在这个例子中，我们定义了一个递归方法，调用recursivePrint它打印一个整数，然后调用自身，下一个连续的整数作为参数。 使用-Xss1M指定线程堆栈大小等于1MB 的标志的示例执行如下所示： 12345678910111213141516171819202122Number: 1Number: 2Number: 3...Number: 6262Number: 6263Number: 6264Number: 6265Number: 6266Exception in thread \"main\" java.lang.StackOverflowError at java.io.PrintStream.write(PrintStream.java:480) at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291) at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104) at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185) at java.io.PrintStream.write(PrintStream.java:527) at java.io.PrintStream.print(PrintStream.java:669) at java.io.PrintStream.println(PrintStream.java:806) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:4) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9) 2.2.2 异常(Exception)Java虚拟机规范规定该区域有两种异常： StackOverFlowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出 2.3 本地方法栈本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。 异常(Exception)：Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。 2.4 Java堆Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。 从内存回收角度，Java堆被分为新生代和老年代；这样划分的好处是为了更快的回收内存；从内存分配角度，Java堆可以划分出线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)；这样划分的好处是为了更快的分配内存；对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下： 对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。 另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存. 异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 2.5 方法区 方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。 很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。 运行时常量池(Runtime Constant Pool)是方法区的一部分。 JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。 异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 2.6 运行时常量池运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。 字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。符号引用：编译语言层面的概念，包括以下3类： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符但是该区域不会抛出OutOfMemoryError异常。 3. JVM总结一张图总结一下JVM Java内存模型Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所问。 在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的,他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。 Java对象模型Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型 总结我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。 JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbing.cc/categories/Java/"}],"tags":[{"name":"JVM内存结构","slug":"JVM内存结构","permalink":"http://zhangbing.cc/tags/JVM内存结构/"},{"name":"Java内存模型","slug":"Java内存模型","permalink":"http://zhangbing.cc/tags/Java内存模型/"},{"name":"Java对象模型","slug":"Java对象模型","permalink":"http://zhangbing.cc/tags/Java对象模型/"}]},{"title":"Android App/Activity 启动流程分析","slug":"activitystartstep-1551942246673","date":"2019-03-07T07:04:06.000Z","updated":"2019-03-08T09:26:29.286Z","comments":true,"path":"2019/03/07/activitystartstep-1551942246673/","link":"","permalink":"http://zhangbing.cc/2019/03/07/activitystartstep-1551942246673/","excerpt":"","text":"Android App/Activity 启动流程分析首先我们带着问题来看: 点击了图标之后系统道理做了哪些工作呢？ 应用进程是怎么被启动的呢？ Activity 的生命周期是什么时候被谁调用的呢？ 本文将继续基于 Android Nougat 的 Frameworks 层源码的解答这些问题。 阅读建议：如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。 1.1 调用过程分析1.1.1 Launcher.onClick在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 onClick 方法，packages/apps/Launcher3/src/com/android/launcher3/Launcher.java： 123456789101112131415161718192021222324public void onClick(View v) &#123; ... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; // 从快捷方式图标启动 onClickAppShortcut(v); &#125; else if (tag instanceof FolderInfo) &#123; // 文件夹 if (v instanceof FolderIcon) &#123; onClickFolderIcon(v); &#125; &#125; else if (v == mAllAppsButton) &#123; // “所有应用”按钮 onClickAllAppsButton(v); &#125; else if (tag instanceof AppInfo) &#123; // 从“所有应用”中启动的应用 startAppShortcutOrInfoActivity(v); &#125; else if (tag instanceof LauncherAppWidgetInfo) &#123; // 组件 if (v instanceof PendingAppWidgetHostView) &#123; onClickPendingWidget((PendingAppWidgetHostView) v); &#125; &#125;&#125; 1.1.2 Launcher.onClickAppShortcut如果是快捷方式图标，则调用 onClickAppShortcut 方法进而调用 startAppShortcutOrInfoActivity 方法： 1234567891011121314151617181920212223242526272829@Thunk void startAppShortcutOrInfoActivity(View v) &#123; Object tag = v.getTag(); final ShortcutInfo shortcut; final Intent intent; if (tag instanceof ShortcutInfo) &#123; shortcut = (ShortcutInfo) tag; // 去除对应的 Intent 对象 intent = shortcut.intent; int[] pos = new int[2]; v.getLocationOnScreen(pos); intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight())); &#125; else if (tag instanceof AppInfo) &#123; shortcut = null; intent = ((AppInfo) tag).intent; &#125; else &#123; throw new IllegalArgumentException(\"Input must be a Shortcut or AppInfo\"); &#125; // 调用 startActivitySafely 方法 boolean success = startActivitySafely(v, intent, tag); mStats.recordLaunch(v, intent, shortcut); if (success &amp;&amp; v instanceof BubbleTextView) &#123; mWaitingForResume = (BubbleTextView) v; mWaitingForResume.setStayPressed(true); &#125;&#125; 1.1.3 Launcher.startActivity获取相应 App 的 Intent 信息之后，调用 startActivity 方法：并设置Flags为Intent.FLAG_ACTIVITY_NEW_TASK,启动新的任务栈 12345678910111213141516171819202122232425private boolean startActivity(View v, Intent intent, Object tag) &#123; // 启动新的任务栈 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; ... if (user == null || user.equals(UserHandleCompat.myUserHandle())) &#123; StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy(); try &#123; StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll() .penaltyLog().build()); // 调用 Activity 的 startActivity 方法 startActivity(intent, optsBundle); &#125; finally &#123; StrictMode.setVmPolicy(oldPolicy); &#125; &#125; else &#123; launcherApps.startActivityForProfile(intent.getComponent(), user, intent.getSourceBounds(), optsBundle); &#125; return true; &#125; catch (SecurityException e) &#123; ... &#125; return false;&#125; 1.1.4 Activity.startActivity这里最终调用了 Activity 中的 startActivity 方法，并且设置 Flag 为 FLAG_ACTIVITY_NEW_TASK。到此为止，已经跟启动普通的 Activity 流程汇合起来了，继续往下分析。frameworks/base/core/java/android/app/Activity.java： 1234567891011@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; // 第二个参数为 -1 表示不需要回调 onActivityResult 方法 if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125; 1.1.5 Activity.startActivityForResult调用 Activity 的 startActivityForResult 方法 123456789101112public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; // mParent 是当前 Activity 的父类，此时条件成立 if (mParent == null) &#123; // 调用 Instrumentation 的 execStartActivity 方法 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ... &#125; else &#123; ... &#125;&#125; 1.1.6 Instrumentation.execStartActivityframeworks/base/core/java/android/app/Instrumentation.java： 12345678910111213141516171819public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); // 获取 AMS 的代理对象并调用其 startActivity 方法 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 1.1.7 ActivityManagerProxy.startActivity以上过程是在 Launcher App所在的进程中发生的，由于远程 AMS(ActivityManagerService)跟使用 Service 的 Activity 不在同一个进程中，因此他们之间交互需要通过 Binder IPC 机制的支持，在这个过程中Client 首先获取到 Server 端的代理对象，在 Client 看来 ActivityManagerProxy 对象同样具有 ActivityManagerService 本地对象承诺的能力，因此 Client 可以调用 ActivityManagerProxy 跟 ActivityManagerService 对象进行数据交互，Binder 驱动作为桥梁在他们中间起到中间人的作用。同样，AMS 是运行在 system_server 线程中的，这时 AMS 就相当于 AIDL 中的远程 服务端，App 进程要与 AMS 交互，需要通过 AMS的代理对象 ActivityManagerProxy 来完成，来看 ActivityManagerNative.getDefault() 拿到的是什么：frameworks/base/core/java/android/app/ActivityManagerNative.java： 123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; getDefault 是一个静态变量： 1234567891011121314private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; // 向 ServiceManager 查询一个 key 为 \"activity\" 的引用 IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; ServiceManager 是 Binder IPC通信过程的核心，是上下文的管理者，Binder 服务端必须先向 ServerManager 注册才能够为客户端提供服务，Binder 客户端在与服务端通信之前需要从 ServerManager 中查找并获取 Binder 服务端的引用。 这里通过 “activity“ 这个名字向 ServiceManager 查询 AMS 的引用，获取 AMS 的引用后，调用 asInterface 方法： 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; // 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章 IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; // 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回 return new ActivityManagerProxy(obj);&#125; 因为 AMS 与 Launcher App 不在同一个进程中，这里返回的 IBinder 对象是一个 Binder 代理对象，因此这类将其包装成 ActivityManagerProxy对象并返回，ActivityManagerProxy 是ActivityManagerNative 的内部类，查看 ActivityManagerProxy 类 ： 1234567891011121314151617181920212223242526272829303132333435363738class ActivityManagerProxy implements IActivityManager&#123; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; ... // 调用号为 START_ACTIVITY_TRANSACTION mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; ... public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws RemoteException &#123; ... mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); ComponentName res = ComponentName.readFromParcel(reply); data.recycle(); reply.recycle(); return res; &#125; ...&#125; 可以看到，ActivityManagerProxy 里面将客户端的请求通过 mRemote.transact 进行转发，mRemote 对象正是 Binder 驱动返回来的 Binder 服务端的 Proxy 对象，通过 这个Binder Proxy，Binder 驱动最终将调用处于 Binder Server 端 ActivityManagerNative 中的 onTransact 方法： 12345678910111213141516171819202122232425@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // 根据方法调用号 code 决定调用哪个方法 switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; ... // 调用 startActivity 方法 int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; ... case START_SERVICE_TRANSACTION: &#123; ... ComponentName cn = startService(app, service, resolvedType, callingPackage, userId); reply.writeNoException(); ComponentName.writeToParcel(cn, reply); return true; &#125; ... &#125;&#125; 1.1.8 ActivityManagerService.startActivityActivityManagerNative 是一个抽象类，它的 startActivity 为抽象方法，具体的实现在 frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 中： 12345678@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; 1.2 小结你应该可以发现，相对于 AIDL 的调用过程，调用方 Launcher App 相当于 AIDL 过程中的 Clinent端；AMS 相当于远程 Service 的角色，充当 Server 端角色，他们的调用过程总体上都是一样的。从 Launcher App 到 AMS 的时序图如下： 2. AMS —— zygote2.1 调用过程分析2.1.1 ActivityManagerService.startActivityAsUser接着从 AMS 的 startActivityAsUser 方法开始分析： 12345678910111213@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. // 调用 ActivityStarter 的 startActivityMayWait 方法 return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);&#125; 2.1.2 ActivityStarter.startActivityMayWait继续跟进 frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java： 123456789101112131415161718192021final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ... synchronized (mService) &#123; ... // 调用 startActivityLocked 方法 int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask); ... return res; &#125;&#125; 2.1.3 ActivityStarter.startActivityLocked查看 startActivityLocked 方法： 1234567891011121314final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ... // 调用 doPendingActivityLaunchesLocked 方法，传入 false 参数 doPendingActivityLaunchesLocked(false); ... return err;&#125; 2.1.4 ActivityStarter.doPendingActivityLaunchesLocked查看 doPendingActivityLaunchesLocked 方法： 12345678910111213141516final void doPendingActivityLaunchesLocked(boolean doResume) &#123; while (!mPendingActivityLaunches.isEmpty()) &#123; final PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); final boolean resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty(); try &#123; // 调用 startActivityUnchecked 方法 final int result = startActivityUnchecked(pal.r, pal.sourceRecord, null, null, pal.startFlags, resume, null, null); postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, mSourceRecord, mTargetStack); &#125; catch (Exception e) &#123; Slog.e(TAG, \"Exception during pending activity launch pal=\" + pal, e); pal.sendErrorResult(e.getMessage()); &#125; &#125;&#125; 2.1.5 ActivityStarter.startActivityUnchecked查看 startActivityUnchecked 方法： 123456789private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ... // 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法 mSupervisor.resumeFocusedStackTopActivityLocked(); ... return START_SUCCESS;&#125; 2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLockedframeworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java： 123456789101112boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; // 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法 mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false;&#125; 2.1.7 ActivityStack.resumeTopActivityUncheckedLocked查看 ActivityStack 的 resumeTopActivityUncheckedLocked 方法：1234567891011boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ... try &#123; ... // 调用 resumeTopActivityInnerLocked 方法 result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 2.1.8 ActivityStack.resumeTopActivityInnerLocked查看 resumeTopActivityInnerLocked 方法：12345678910111213141516private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... final ActivityRecord next = topRunningActivityLocked(); ... if (next.app != null &amp;&amp; next.app.thread != null) &#123; ... &#125; else &#123; ... if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Restarting \" + next); // 调用 ActivityStackSupervisor 的 startSpecificActivityLocked 方法 mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; 2.1.9 ActivityStackSupervisor.startSpecificActivityLocked回到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法：123456789101112131415161718192021222324void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // 当前 Activity 附属的 Application ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); // 如果 Application 已经运行 if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; &#125; // 如果 Application 没有运行,调用AMS,启动新进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 首先，在方法中获取了当前 Activity 附属的 Application，如果已经在运行了，说明这个 App 是已经被启动过了的，这时候调用 realStartActivityLocked 方法就可以进入下一步的流程了，同一个 App 中不同 Activity 的相互启动就是走的这个流程。当 Application 没有运行的时候，就需要调用 AMS 的 startProcessLocked 方法启动一个进程去承载它然后完成后续的工作，顺便铺垫一下，当新进程被启动完成后还会调用回到这个方法，查看 AMS 的 startProcessLocked 方法： 2.1.10 ActivityManagerService.startProcessLocked123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123; return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */);&#125; 2.1.11 ActivityManagerService.startProcessLocked调用 startProcessLocked 方法：123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)&#123; ... startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, \"startProcess: done starting proc!\"); return (app.pid != 0) ? app : null;&#125; 2.1.12 ActivityManagerService.startProcessLocked调用 startProcessLocked 的重载方法：123456789101112131415private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)&#123; ... try &#123; ... // 调用 Process 的 start 方法 Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); ... &#125; catch (RuntimeException e) &#123; ... &#125;&#125; 2.1.13 Process.startframeworks/base/services/core/java/android/os/Process.java：12345678910111213141516171819202122public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; // 调用 startViaZygote 方法 return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; 2.1.14 Process.startViaZygote查看 startViaZygote 方法：123456789101112131415161718private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ... // 调用 zygoteSendArgsAndGetResult 方法，传入 openZygoteSocketIfNeeded 的返回值 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125; 2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded查看 zygoteSendArgsAndGetResult 方法：1234567891011121314151617181920212223242526272829303132333435private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; ... final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // 等待 socket 服务端（即zygote）返回新创建的进程pid; result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125;&#125; 在 zygoteSendArgsAndGetResult 中等待 Socket 服务端，也就是 zygote 进程返回创建新进程的结果，这里 zygoteState 参数是由 openZygoteSocketIfNeeded 方法返回的，openZygoteSocketIfNeeded 方法则负责根据 abi 向 Zygote 进程发起连接请求：1234567891011121314151617181920212223242526272829private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; // 向主zygote发起connect()操作 primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; // 当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作 secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 2.2 小结如果是从桌面新启动一个 App 中的 Activity，此时是没有进程去承载这个 App 的，因此需要通过 AMS 向 zygote 继承发起请求去完成这个任务，AMS 运行在 system_server 进程中，它通过 Socket 向 zygote 发起 fock 进程的请求，从 AMS 开始的调用时序图如下： 3. zygote —— ActivityThread3.1 调用过程分析3.1.1 ZygoteInit.mainzygote 进程的其中一项任务就是： 调用 registerZygoteSocket()函数建立 Socket 通道，使 zygote 进程成为 Socket 服务端，并通过runSelectLoop() 函数等待 ActivityManagerService 发送请求创建新的应用程序进程。 zygote 终于要再次上场了！接下来从 ZygoteInit.java 的 main 方法开始回顾一下 zygote 进程的工作： frameworks/base/core/java/com/android/internal/os/ZygoteInit.java：123456789101112public static void main(String argv[]) &#123; try &#123; ... runSelectLoop(abiList); .... &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; closeServerSocket(); throw ex; &#125;&#125; 3.1.2 ZygoteInit.runSelectLoop查看 runSelectLoop 方法：12345678910111213141516171819202122232425private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ... // 循环读取状态 while (true) &#123; ... for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; // 读取的状态不是客户端连接或者数据请求时，进入下一次循环 if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123;// i = 0 表示跟客户端 Socket 连接上了 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123;// i &gt; 0 表示接收到客户端 Socket 发送过来的请求 // runOnce 方法创建一个新的应用程序进程 boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 3.1.3 ZygoteConnection.runOnce查看 frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 的 runOnce 方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; // 读取 socket 客户端发送过来的参数列表 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; // EOF reached. closeSocket(); return true; &#125; ... try &#123; // 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式 parsedArgs = new Arguments(args); ... // 同样调用 Zygote.java 的 forkAndSpecialize 方法 fock 出子进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (Exception e) &#123; ... &#125; try &#123; if (pid == 0) &#123; // 子进程执行 IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; // 进入子进程流程 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); return true; &#125; else &#123; // 父进程执行 IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 3.1.4 ZygoteConnection.handleChildProc首先解析 Socket 客户端传过来的参数，Zygote.java 的 forkAndSpecialize 返回的 pid == 0 的时候表示此时在 fock 出来的子进程中执行，继续调用 handleChildProc 方法，并将参数继续层层传递：123456789101112131415161718192021private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; /*由于 fock 出来的 system_server 进程会复制 zygote 进程的地址空间，因此它也得到了 zygote 进程中的 Socket，这个 Socket 对它来说并无用处，这里将其关闭 */ closeSocket(); ZygoteInit.closeServerSocket(); ... if (parsedArgs.niceName != null) &#123; // 设置进程名 Process.setArgV0(parsedArgs.niceName); &#125; if (parsedArgs.invokeWith != null) &#123; ... &#125; else &#123; // 调用 RuntimeInit 的 zygoteInit 方法 RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null); &#125;&#125; 3.1.5 RuntimeInit.zygoteInit查看 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 的 zygoteInit 方法：12345678910111213141516public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); // 重定向 log 输出 redirectLogStreams(); // 初始化一些通用的设置 commonInit(); /** *通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 的 *onZygoteInit 方法启动 Binder 线程池， 使 system_server 进程可以使用 Binder *与其他进程通信 **/ nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 3.1.6 RuntimeInit.applicationInit继续调用 applicationInit 方法：123456private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; ... // 提取出参数里面的要启动的类的名字 invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125; 3.1.7 RuntimeInit.invokeStaticMain主要调用了 invokeStaticMain 方法：123456789101112131415161718192021222324252627282930private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; /** className 为通过 Socket 客户端（AMS）传递过来的一系列参数中的其中一个，这里获取到的值为传\"com.android.app.ActivityThread\"，然后通过反射得到 ActivityThread 类 **/ cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; // 找到 ActivityThread 类的 main 方法 m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出 捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 3.1.8 MethodAndArgsCaller.run回到 ZygoteInit 的 main 方法：123456789101112public static void main(String argv[]) &#123; ... closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; // 接收到 caller 对象后调用它的 run 方法 caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 跟 system_server 进程的启动过程一样，这里同样通过抛出异常的方式来清空调用 ActivityThread.main之前的方法栈帧。ZygoteInit 的 MethodAndArgsCaller 类是一个 Exception 类，同时也实现了 Runnable 接口：123456789101112131415161718192021public static class MethodAndArgsCaller extends Exception implements Runnable &#123; private final Method mMethod; private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; // 调用传递过来的 mMethod mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; ... &#125; &#125;&#125; 3.1.9 ActivityThread .main最后通过反射调用到 ActivityThread 的 main 方法：12345678910111213141516171819202122public static void main(String[] args) &#123; ... Environment.initForCurrentUser(); ... Process.setArgV0(\"&lt;pre-initialized&gt;\"); // 创建主线程 Looper Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); // attach 到系统进程 thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; // 主线程进入轮询状态 Looper.loop(); // 抛出异常说明轮询出现问题 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 3.2 小结zygote 进程作为 Socket 服务端在接收到作为客户端的 AMS 发送过来的请求和参数之后，fock 出新的进程并根据各种参数进程了初始化的工作，这个过程和 zygote 启动 system_server 进程的过程如出一辙，时序图如下所示： 4. ActivityThread —— Activity##4.1 调用过程分析 4.1.1 ActivityThread.attach上一小节的最后，ActivityThread 的 main 通过反射被运行起来了，接着会调用 ActivityThread 的 attach 方法： 123456789101112131415161718private void attach(boolean system) &#123; ... mSystemThread = system; if (!system) &#123; ... // 获取 ActivityManagerProxy 对象 final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; // 通过 Binder 调用 AMS 的 attachApplication 方法 mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; else &#123; ... &#125; ...&#125; 这里，我们再一次通过 Binder IPC 机制跟 AMS 通信，通信模型跟前面Launcher App调用 AMS 的 startActivity 方法一样，getDefault 过程不重复分析，这次是调用了 AMS 的 attachApplication 方法，注意这里将 ApplicationThead 类型的 mAppThread 对象作为参数传递了过去，ApplicationThead 是 ActivityThread 的一个内部类，后面我们会讲到，先查看 AMP 的 attachApplication 方法： 4.1.2 ActivityManagerProxy.attachApplication12345678910public void attachApplication(IApplicationThread app) throws RemoteException &#123; ... // 调用 asBinder 方法使其能够跨进程传输 data.writeStrongBinder(app.asBinder()); // 通过 transact 方法将数据交给 Binder 驱动 mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 4.1.3 ActivityManagerNative.onTransact123456789101112131415161718public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; ... case ATTACH_APPLICATION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); // 获取 ApplicationThread 的代理对象，这里返回的是 ApplicationThreadNative(ATN) // 的内部类：ApplicationThreadProxy(ATP) 对象 IApplicationThread app = ApplicationThreadNative.asInterface(data.readStrongBinder()); if (app != null) &#123; // 委托给 AMS 执行 attachApplication(app); &#125; reply.writeNoException(); return true; &#125; ... &#125;&#125; asInterface 将 ActivityThread 对象转换成了 ApplicationThreadNative 的 Binder 代理对象 ApplicationThreadProxy，并作为参数传给 attachApplication 方法，其中 ApplicationThreadProxy 是 ApplicationThreadNative 的内部类。 4.1.4 ActivityManagerService.attachApplication12345678public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; 4.1.5 ActivityManagerService.attachApplicationLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ProcessRecord app; ... try &#123; // 绑定死亡通知 AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; &#125; catch (RemoteException e) &#123; app.resetPackageList(mProcessStats); // 如果 system_server 进程死亡则重新启动进程 startProcessLocked(app, \"link fail\", processName); return false; &#125; ... try &#123; ... // 获取应用appInfo ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info; ... // 绑定应用 thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); ... &#125; catch (Exception e) &#123; app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); // bindApplication 失败也要重启进程 startProcessLocked(app, \"bind fail\", processName); return false; &#125; // 如果是 Activity: 检查最顶层可见的Activity是否等待在该进程中运行 if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // 如果是 Service: 寻找所有需要在该进程中运行的服务 if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // 如果是 BroadcastReceiver: 检查是否在这个进程中有下一个广播接收者 if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; didSomething |= sendPendingBroadcastsLocked(app); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // 检查是否在这个进程中有下一个 backup 代理 if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.appInfo.uid == app.uid) &#123; ensurePackageDexOpt(mBackupTarget.appInfo.packageName); try &#123; thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; if (badApp) &#123; // 杀掉 badApp app.kill(\"error during init\", true); handleAppDiedLocked(app, false, true); return false; &#125; if (!didSomething) &#123; // 更新 adj(组件的权值) updateOomAdjLocked(); &#125; return true;&#125; 首先，通过 ApplicationThreadProxy 使用 Binder 向 ApplicationThreadProxy 发起 bindApplication 请求，然后通过 normalMode 字段判断是否为 Activity，如果是则执行 ActivityStackSupervisor 的 attachApplicationLocked 方法。 4.1.5.1 ActivityThread.java::ApplicationThread.bindApplicationthread 对象类型是 ApplicationThreadProxy，通过 Binder 驱动调到了 ApplicationThreadNative 的方法，ApplicationThreadNative 是一个抽象类，它的实现都委托给了 ApplicationThread(这跟 AMS 跟 AMN 的关系一样)，ApplicationThread 作为 ActivityThread 的内部类存在，它的 binderApplication 方法如下：12345678910111213141516ActivityThread.java::ApplicationThread：public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; if (services != null) &#123; // 将services缓存起来, 减少binder检索服务的次数 ServiceManager.initServiceCache(services); &#125; ... // 发送消息 H.BIND_APPLICATION 给 Handler 对象 sendMessage(H.BIND_APPLICATION, data);&#125; H 是 ActivityThread 中的一个 Handler 对象，用于处理发送过来的各种消息：1234567891011121314private class H extends Handler &#123; public static final int BIND_APPLICATION = 110; public void handleMessage(Message msg) &#123; ... case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... &#125;&#125; 调用了 handleBindApplication 方法：1234567891011121314151617181920212223242526private void handleBindApplication(AppBindData data) &#123; // 获取 LoadedApk 对象 data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... // 创建 ContextImpl 上下文 final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); ... // 创建 Instrumentation 对象 if (data.instrumentationName != null) &#123; ... &#125; else &#123; mInstrumentation = new Instrumentation(); &#125; try &#123; // 调用 LoadedApk 的 makeApplication 方法创建 Application Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... mInstrumentation.onCreate(data.instrumentationArgs); // 调用 Application.onCreate 方法 mInstrumentation.callApplicationOnCreate(app); &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125;&#125; 4.1.5.2 ActivityStackSupervisor.attachApplicationLocked在 4.1.4 小节中通过 Binder 向 ActivityThread 发起 bindApplication 请求后，会根据启动组件的类型去做相应的处理，如果是 Acitivity，则会调用 ActivityStackSupervisor 的 attachApplicationLocked 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; // 获取前台stack中栈顶第一个非 finishing 状态的 Activity ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; // 真正的启动 Activity if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (RemoteException e) &#123; throw e; &#125; &#125; &#125; &#125; &#125; ... return didSomething;&#125;##### 4.1.5.2.1 ActivityStackSupervisor.realStartActivityLocked前面 **2.1.8ActivityStackSupervisor.startSpecificActivityLocked** 小节中分析过，如果当前 `Activity` 依附的 `Application` 已经被启动，则调用 `realStartActivityLocked` 方法，否则创建新的进程，再创建新的进程之后，两个流程的在这里合并起来了：```javafinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... final ActivityStack stack = task.stack; try &#123; ... app.forceProcessStateUpTo(mService.mTopProcessState); // 通过 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法 app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... &#125; catch (RemoteException e) &#123; if (r.launchFailed) &#123; // 第二次启动失败，则结束该 Activity mService.appDiedLocked(app); stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null, \"2nd-crash\", false); return false; &#125; // 第一个启动失败，则重启进程 app.activities.remove(r); throw e; &#125; ... return true;&#125;``` 这里有一次使用 `Binder` 调用 `ApplicationThread` 的 `scheduleLaunchActivity` 方法。##### 4.1.5.2.2 ApplicationThread.scheduleLaunchActivity```javapublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ... updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); ... sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 上面提到过，H 是 ActivityThread 中一个 Handler 类，它接收到 LAUNCH_ACTIVITY 消息后会调用 handleLaunchActivity 方法。 4.1.5.2.3 ActivityThread.handleLaunchActivity123456789101112131415161718192021222324private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... // 初始化 WMS WindowManagerGlobal.initialize(); // 执行 performLaunchActivity 方法 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; // 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); r.paused = true; &#125; &#125; else &#123; // 停止该 Activity ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); &#125;&#125; 4.1.4.2.4 ApplicationThread.performLaunchActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); // Instrumentation 中使用反射创建 Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); ... &#125; catch (Exception e) &#123; ... &#125; try &#123; // 创建 Application 对象并调用 Application 的 onCreate 方法 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; ... // attach 到 Window 上 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; // 设置主题 activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; // 重新创建的 Activity mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; // 第一次创建的 Activity mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... &#125; ... &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; 4.1.5.2.5 Instrumentation.callActivityOnCreate1234567public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123; prePerformCreate(activity); // 调用 Activity 的 performCreate 方法 activity.performCreate(icicle, persistentState); postPerformCreate(activity);&#125; 4.1.5.2.6 Activity.performCreate123456final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle, persistentState); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; 终于，onCreate 方法被调用了！！！ 4.2 小结从 ActivityThread 到最终 Activity 被创建及生命周期被调用，核心过程涉及到了三次 Binder IPC 过程，分别是： 1. ActivityThread 调用 AMS 的 attachApplication 方法 2. AMS 调用 ApplicationThread 的 bindApplication 方法 3. ActivityStackSupervisor 调用 Application 的 attachApplicationLocked 方法 整个过程的时序图如下： 总结纵观整个过程，从 Launcher 到 AMS、从 AMS 再到 Zygote、再从 Zygote 到 ActivityThread，最后在 ActivitThread 中层层调用到 Activity 的生命周期方法，中间涉及到了无数的细节，但总体上脉络还是非常清晰的，各个 Android 版本的 Framework 层代码可以某些过程的实现不太一样，但是整个调用流程大体上也是相同的，借用 Gityuan 大神的一张图作为结尾：","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangbing.cc/categories/Android/"}],"tags":[{"name":"Activity 启动流程分析","slug":"Activity-启动流程分析","permalink":"http://zhangbing.cc/tags/Activity-启动流程分析/"}]},{"title":"深入理解Android 消息机制：Handler、MessageQueue 和 Looper","slug":"HandlerMessagequeueLooper-1551427172528","date":"2019-03-01T07:59:32.000Z","updated":"2019-03-08T09:25:40.081Z","comments":true,"path":"2019/03/01/HandlerMessagequeueLooper-1551427172528/","link":"","permalink":"http://zhangbing.cc/2019/03/01/HandlerMessagequeueLooper-1551427172528/","excerpt":"Android 消息机制：Handler、MessageQueue 和 Looper在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：","text":"Android 消息机制：Handler、MessageQueue 和 Looper在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解： 1、Handler 的作用通常，当我们在非主线程当中做了异步的操作之后使用 Handler 来在主线程当中更新 UI。之所以这么设计无非就是因为 Android 中的 View 不是线程安全的。之所以将 View 设计成非线程安全的，是因为： 1).对 View 进行加锁之后会增加控件使用的复杂度；2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI， 确切来说它有两个作用： 任务调度：即通过 post() 和 send() 等方法来指定某个任务在某个时间执行； 线程切换：你也许用过 RxJava，但如果在 Android 中使用的话还要配合 RxAndroid，而这里的 RxAndroid 内部就使用 Handler 来实现线程切换。 下文中，我们就来分别看一下它的这两个功能的作用和原理。 1.1 任务调度使用 Hanlder 可以让一个任务在某个时间点执行或者等待某段时间之后执行。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 post() 和 sned() 两类方法。post() 类的用来指定某个 Runnable 在某个时间点执行，send() 类的用来指定某个 Message 在某个时间点执行。这里的 Message 是 Android 中定义的一个类。它内部有多个字段，比如 what、arg1、arg2、replyTo 和 sendingUid 来帮助我们指定该消息的内容和对象。同时， Message 还实现了 Parcelable 接口，这表明它可以被用来跨进程传输。此外，它内部还定义了一个 Message 类型的 next 字段，这表明 Message 可以被用作链表的结点。实际上 MessageQueue 里面只存放了一个 mMessage，即链表的头结点。所以，MessageQueue 内部的消息队列，本质上是一个单链表，每个链表的结点就是 Message。当调用 post() 类型的方法来调度某个 Runnable 的时候，首先会将其包装成一个 Message，然后再使用 send()类的方法进行任务分发。所以，不论是 post() 类的方法还是 send() 类的方法，最终都会使用 Handler 的 sendMessageAtTime() 方法来将其加入到队列中：12345678public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; // ... 无关代码 return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 使用 Handler 进行任务调度是非常简单的。下面的代码就实现了让一个 Runnable 在 500ms 之后执行的逻辑： 123456new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; // do something &#125;&#125;, 500); 上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。既然每个 Runnable 被 post() 发送之后还要被包装成 Message，那么 Message 的意义何在呢？Runnable 被包装的过程依赖于 Handler 内部的 getPostMessage() 方法。下面是该方法的定义： 12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 可见，我们的 Runnable 会被赋值给 Message 的 callback。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要： 首先，要使用 send() 类型的方法来传递我们的 Message 给 Handler； 然后，我们的 Handler 要覆写 handleMessage() 方法，并在该方法中获取每个 Message 并根据其内部的信息依次处理。 下面的一个例子用来演示 send() 类型的方法。首先，我们要定义 Handler 并覆写其 handleMessage() 方法来处理消息： 123456789101112private final static int SAY_HELLO = 1;private static Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SAY_HELLO: LogUtils.d(\"Hello!\"); break; &#125; &#125;&#125;; 然后，我们向该 Handler 发送消息： 123Message message = Message.obtain(handler);message.what = SAY_HELLO;message.sendToTarget(); 这样，我们的 Handler 接收到了消息并根据其 what 得知要 SAY_HELLO，于是就打印出了日志信息。除了调用 Message 的 sendToTarget() 方法，我们还可以直接调用 handler 的 sendMessage() 方法（sendToTarget() 内部调用了 handler 的 sendMessage()）。 1.2 线程切换下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。 123456789101112// 在主线程中获取 Handlerprivate static Handler handler = new Handler(); // 更新UI，会将消息发送到主线程当中new Thread(() -&gt; &#123; try &#123; Thread.sleep(2000); handler.post(() -&gt; getBinding().tv.setText(\"主线程更新UI\")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start(); 上面之所以能够在主线程当中更新 UI，主要是因为我们的 Handler 是在主线程当中进行获取的。随后，我们调用 handler 的 post() 方法之后，传入的 Runnable 会被包装成 Message，然后加入到主线程对应的消息队列中去，并由主线程对应的 Looper 获取到并执行。所以，就使得该 Runnable 的操作最终在主线程中完成。也许你会觉得先在主线程当中获取到 Handler 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 Looper 的 getMainLooper() 方法来获取主线程对应的 Looper，然后使用它来实例化一个 Handler 并使用该 Handler来处理消息： 12new Handler(Looper.getMainLooper()) .post(() -&gt; getBinding().tv.setText(\"主线程更新UI\")); 本质上，当我们调用 Handler 的无参构造方法，或者说不指定 Looper 的构造方法的时候，会直接使用当前线程对应的 Looper 来实例化 Handler。每个线程对应的 Looper 存储在该线程的局部变量 ThreadLocal 里。当某个线程的局部变量里面没有 Looper 的时候就会抛出一个异常。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。主线程对应的 Looper 会在 ActivityThread 的静态方法 main() 中被创建，它会调用 Looper 的 prepareMainLooper() 静态方法来创建主线程对应的 Looper。然后会调用 Looper 的 loop() 静态方法来开启 Looper 循环以不断处理消息。这里的 ActivityThread 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。ActivityThread 内部定义了一个内部类 H，它继承自 Handler，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 Looper。下面的代码中，我们开启了一个线程，并在线程中先调用 Looper 的 prepare() 静态方法，此时 Looper 会为我们当前的线程创建 Looper，然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息： 123456new Thread(() -&gt; &#123; LogUtils.d(\"+++++++++\" + Thread.currentThread()); Looper.prepare(); new Handler().post(() -&gt; LogUtils.d(\"+++++++++\" + Thread.currentThread())); Looper.loop();&#125;).start(); 从以上的内容我们可以看出，Handler 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 ThreadLocal 来对每个线程对应的Looper中的消息队列进行存储。 2、源码解析以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。 2.1 实例化 HandlerHandler 提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 Looper，另一种在构造方法中不需要指定任何 Looper，在构造方法内部会获取当前线程对应的 Looper 来初始化 Handler。第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作： 123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 第二种初始化的方式最终会调用下面的方法。这里使用 Looper 的静态方法 myLooper() 来获取当前线程对应的 Looper。如果当前线程不存在任何 Looper 就会抛出一个异常。 1234567891011121314151617181920public Handler(Callback callback, boolean async) &#123; // 潜在内存泄漏的检查 if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; // 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException(); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 而 Looper 的静态方法 myLooper() 会使用线程局部变量 sThreadLocal 来获取之前存储到该线程内部的 Looper： 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 2.2 Looper 的初始化前面我们也说过 Looper 的创建过程。对于主线程的 Looper 会在 ActivityThread 的 main() 方法中被调用： 12345678public static void main(String[] args) &#123; // ... 无关代码 Looper.prepareMainLooper(); // ... 无关代码 // 开启 Looper 循环 Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 这里调用了 Looper 的静态方法 prepareMainLooper() 来初始化主线程的 Looper： 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; 其内部先调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中，然后判断 sMainLooper 是否之前存在过。这是一种基本的单例校验，显然，我们只允许主线程的 Looper 被实例化一次。同样，非主线程的 Looper 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 prepare() 静态方法。它同样调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。 下面是 prepare() 方法的代码:12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 经过上述分析，我们可以得知，对于一个线程只能实例化一个 Looper，所以当我们在同一个线程中多次创建 Handler 实例，它们是共享一个 Looper 。或者说是一个 Looper 对应多个 Handler 也是可以的。 2.3 MessageQueue 的实例化相比于 Looper 和 Handler，MessageQueue 就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 native 的方法。你可以在 android_os_MessageQueue 查看其源码的定义。每当我们实例化一个 Looper 的时候会调用它的构造方法，并在其中实例化一个 MessageQueue： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在实例化 Handler 的小节中可以看出，每次实例化一个 Handler 的时候，会从当前线程对应的 Looper 中取出 MessageQueue。所以，这里我们又可以得出结论: 一个 Handler 对应一个 MessageQueue。 当我们实例化一个 MessageQueue 的时候会使用它的构造方法。这里会调用 native 层的 nativeInit() 方法来完成 MessageQueue 的初始化： 1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 在 native 层，nativeInit() 方法的定义如下： 123456789static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 上面我们可以看出，在该方法中实例化了一个NativeMessageQueue 之后返回了 mPtr 作为是 Java 层 MessageQueue 与NativeMessesageQueue 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 MessageQueue 同样使用 mPtr 来表示 native 层的消息队列。NativeMessageQueue 在 native 层的部分定义和其构造方法的定义如下。 12345678910class NativeMessageQueue : public MessageQueue, public LooperCallback &#123;// ... 无关代码NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 从上面我们可以看出，NativeMessageQueue 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper （其源码在 Looper）。 在 Android 的 native 层存在着一个于 Java 层类似的 Looper，它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信。当消息队列中有消息存入时，会唤醒 Native 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Native 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。 既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？ 这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长以至于无法处理其他事件的时候才会出现 ANR。上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下： 12345678910111213141516171819202122232425void Looper::rebuildEpollLocked() &#123; // 如果之前存在的话就关闭之前的 epoll 实例 if (mEpollFd &gt;= 0) &#123; mEpollFd.reset(); // 关闭旧的epoll实例 &#125; // 申请新的 epoll 实例，并且注册 “Wake管道” mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT)); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance: %s\", strerror(errno)); struct epoll_event eventItem; // 把未使用的数据区域进行置0操作 memset(&amp; eventItem, 0, sizeof(epoll_event)); eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd.get(); // 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd) int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\", strerror(errno)); // 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加 for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); // 将 request 队列的事件，分别添加到 epoll 实例 int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem); &#125;&#125; 这里涉及了 epoll 相关的知识。epoll 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。上面的代码中使用了 epoll_ctl 方法来将被监听的描述符添加到 epoll 句柄。关于 epoll 的指令，可以参考这篇博文 《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》。这部分代码的主要作用是创建一个 epoll 实例并用它来监听 event 触发。 2.4 消息的执行过程2.4.1 消息入队的过程在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 从上面可以看出，入队的时候实际上是使用了 MessageQueue 的 enqueueMessage() 方法。所以，我们再来看下该方法的定义： 123456789101112131415161718192021222324252627282930313233boolean enqueueMessage(Message msg, long when) &#123; // ... 无关代码，校验 synchronized (this) &#123; // ... 无关代码 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。这里的 nativeWake() 方法会最终调用 native 层的 Looper 的 awake() 方法： 123456789void Looper::wake() &#123; uint64_t inc = 1; ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d: %s\", mWakeEventFd.get(), strerror(errno)); &#125; &#125;&#125; 2.4.2 消息执行的过程在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。 123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper(); // .. 无关代码 final MessageQueue queue = me.mQueue; // .. 无关代码 for (;;) &#123; Message msg = queue.next(); // 可能会 bolck if (msg == null) &#123; return; &#125; // ... 无关代码 final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; // ... 无关代码 msg.recycleUnchecked(); &#125;&#125; 从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 MessageQueue 的 next() 方法来取出下一个消息并进行分发。这里我们先不看 next() 方法的定义。我们先把这个方法中涉及的部分分析一下。当获取到了下一个消息之后，会调用它的target 也就是发送该消息的 Handler 的 dispatchMessage() 方法来进行处理。该方法的定义如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 从上面可以看出，如果该消息是通过包装 Runnable 得到的话，会直接调用它的 handleCallback() 方法进行处理。在该方法内部会直接调用 Runnable 的 run() 方法。因为比较见到那，我们就不贴出代码了。然后，会根据 mCallback 是否为空来决定是交给 mCallback 进行处理还是内部的 handleMessage() 方法。这里的 mCallback 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 handleMessage() 方法，我们就再熟悉不过了，它就是我们创建 Handler 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 Handler 中进行处理了。以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 MessageQueue 是如何获取 “下一个” 消息的。 2.4.3 MessageQueue 的消息管理上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑： 1234567891011121314151617Message next() &#123; // 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。 final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 调用 native 的方法，可能会这个函数发生 block nativePollOnce(ptr, nextPollTimeoutMillis); // ... 无关代码 &#125;&#125; 从上面可以看出 Java 层的 MessageQueue 的 next() 方法是一个循环。除了获取消息队列之外，还要监听Natvie 层 Looper 的事件触发。通过调用 native 层的 nativePollOnce() 方法来实现。该方法内部又会调用 NativeMessageQueue 的 pollOnce() 方法。而且注意下，在下面的方法中，nativeMessageQueue 是从 Java 层的 mPtr 中获取到的。所以我们说，在初始化 MessageQueue 的时候得到的 mPtr 起到了桥梁的作用： 12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 在 NativeMessageQueue 的 pollOnce() 方法中会调用 native 层的 Looper 的 pollOnce()，并最终调用 native 层 Looper 的 pollInner() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192int Looper::pollInner(int timeoutMillis) &#123; // ... 根据下一个消息的事件调整超时时间 int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; // 将要空闲 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 待已注册之事件被触发或计时终了 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; // 不再空闲 mLock.lock(); // 请求锁 if (mEpollRebuildRequired) &#123; mEpollRebuildRequired = false; rebuildEpollLocked(); // 根据需要重建 epoll goto Done; &#125; // 进行检查 if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; result = POLL_ERROR; // 错误 goto Done; &#125; if (eventCount == 0) &#123; result = POLL_TIMEOUT; // 超时 goto Done; &#125; // 处理所有消息 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd.get()) &#123; // 唤醒 fd 有反应 if (epollEvents &amp; EPOLLIN) &#123; awoken(); // 已经唤醒了，则读取并清空管道数据 &#125; &#125; else &#123; // 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; // 将消息放进 mResponses 中 pushResponse(events, mRequests.valueAt(requestIndex)); &#125; &#125; &#125;Done: ; // 触发所有的消息回调，处理 Native 层的Message mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; &#123; // 获取 handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); &#125; // 释放 handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; &#125; else &#123; // 队列头部的消息决定了下个唤醒的时间 mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; mLock.unlock(); // 释放锁 // 触发所有的响应回调 for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); // 移除文件描述符 &#125; response.request.callback.clear(); result = POLL_CALLBACK; &#125; &#125; return result;&#125; 从上面我们可以看出 Native 层的 pollInner() 方法首先会根据 Java 层传入的 timeoutMillis 调用 epoll_wait 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 enqueueMessage() 方法的最后几行代码： 123if (needWake) &#123; nativeWake(mPtr);&#125; 即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。 3、总结在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。 3.1 Handler、MessageQueue 和 Looper 之间的关系首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示： HandlerMessageQueueLooper 也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。 3.2 Handler 的消息发送过程然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析： Handler 根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 Message 类型的数据。但不论哪种类型最终都会调用 Handler 的 sendMessageAtTime() 方法来加入到 MessageQueue 的队列中。区别在于，post 类型的方法需要经过 Handler 的 getPostMessage() 包装成 Message 之后再发送。 3.3 Looper 的执行过程当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 loop() 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述： Looper 当我们调用 Looper 的 loop()方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 next() 方法来获取下一个消息的时候，会调用 nativePollOnce() 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangbing.cc/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://zhangbing.cc/tags/Handler/"},{"name":"MessageQueue","slug":"MessageQueue","permalink":"http://zhangbing.cc/tags/MessageQueue/"},{"name":"Looper","slug":"Looper","permalink":"http://zhangbing.cc/tags/Looper/"},{"name":"Android 消息机制","slug":"Android-消息机制","permalink":"http://zhangbing.cc/tags/Android-消息机制/"}]},{"title":"ThreadLocal 源码深入分析","slug":"ThradLocalCodeRead1551409309746","date":"2019-03-01T03:01:49.000Z","updated":"2019-03-08T09:25:55.534Z","comments":true,"path":"2019/03/01/ThradLocalCodeRead1551409309746/","link":"","permalink":"http://zhangbing.cc/2019/03/01/ThradLocalCodeRead1551409309746/","excerpt":"ThreadLocal 源码深入分析以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～ ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 GC。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal 通常定义为 private static 类型。 假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，Thread作为key，变量作为value。事实上，JDK 中确实使用了类似 Map 的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中ThreadLocal的实现。","text":"ThreadLocal 源码深入分析以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～ ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 GC。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal 通常定义为 private static 类型。 假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，Thread作为key，变量作为value。事实上，JDK 中确实使用了类似 Map 的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中ThreadLocal的实现。 初探 ThreadLocal我们从 ThreadLocal 的几个成员变量入手： 12345678910111213141516171819private final int threadLocalHashCode = nextHashCode();/** * The next hash code to be given out. Updated atomically. Starts at * zero. */private static AtomicInteger nextHashCode = new AtomicInteger();/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; ThreadLocal 通过 threadLocalHashCode 来标识每一个 ThreadLocal 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(这个数的原理没有探究)。 再看 set 方法： 1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 可以看到通过Thread.currentThread()方法获取了当前的线程引用，并传给了getMap(Thread)方法获取一个ThreadLocalMap的实例。我们继续跟进getMap(Thread)方法： 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 可以看到getMap(Thread)方法直接返回Thread实例的成员变量threadLocals。它的定义在Thread内部，访问级别为package级别： 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 到了这里，我们可以看出，每个Thread里面都有一个ThreadLocal.ThreadLocalMap成员变量，也就是说每个线程通过ThreadLocal.ThreadLocalMap与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。 我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals。 ThreadLocal#createMap方法的源码如下： 1234void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 下面我们探究一下 ThreadLocalMap 的实现。 ThreadLocalMapThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下： ThreadLocalMap 可以看到ThreadLocalMap有一个常量和三个成员变量： 1234567891011121314151617/** * The initial capacity -- MUST be a power of two. */private static final int INITIAL_CAPACITY = 16;/** * The table, resized as necessary. * table.length MUST always be a power of two. */private Entry[] table;/** * The number of entries in the table. */private int size = 0;/** * The next size value at which to resize. */private int threshold; // Default to 0 其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。 Entry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下： 12345678910111213141516/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。 ThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)： 123456789101112/** * Construct a new map initially containing (firstKey, firstValue). * ThreadLocalMaps are constructed lazily, so we only create * one when we have at least one entry to put in it. */ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。 注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 2的指数，因为这可以使得hash发生冲突的次数减小。 接下来我们来看ThreadLocalMap#set方法的实现： 1234567891011121314151617181920212223242526272829303132/** * Set the value associated with key. * * @param key the thread local object * @param value the value to be set */private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 如果冲突了，就会通过nextIndex方法再次计算哈希值： 123456/** * Increment i modulo len. */private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125; 到这里，我们看到 ThreadLocalMap 解决冲突的方法是 线性探测法（不断加 1），而不是 HashMap 的 链地址法，这一点也能从 Entry 的结构上推断出来。 如果entry里对应的key为null的话，表明此entry为staled entry，就将其替换为当前的key和value： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Replace a stale entry encountered during a set operation * with an entry for the specified key. The value passed in * the value parameter is stored in the entry, whether or not * an entry already exists for the specified key. * * As a side effect, this method expunges all stale entries in the * \"run\" containing the stale entry. (A run is a sequence of entries * between two null slots.) * * @param key the key * @param value the value to be associated with key * @param staleSlot index of the first stale entry encountered while * searching for key. */private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; 具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。 若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）： 123456789101112131415161718192021222324252627282930313233343536373839/** * Heuristically scan some cells looking for stale entries. * This is invoked when either a new element is added, or * another stale one has been expunged. It performs a * logarithmic number of scans, as a balance between no * scanning (fast but retains garbage) and a number of scans * proportional to number of elements, that would find all * garbage but would cause some insertions to take O(n) time. * * @param i a position known NOT to hold a stale entry. The * scan starts at the element after i. * * @param n scan control: &#123;@code log2(n)&#125; cells are scanned, * unless a stale entry is found, in which case * &#123;@code log2(table.length)-1&#125; additional cells are scanned. * When called from insertions, this parameter is the number * of elements, but when from replaceStaleEntry, it is the * table length. (Note: all this could be changed to be either * more or less aggressive by weighting n instead of just * using straight log n. But this version is simple, fast, and * seems to work well.) * * @return true if any stale entries have been removed. */private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; 一旦发现一个位置对应的 Entry 所持有的 ThreadLocal 弱引用为null，就会把此位置当做 staleSlot 并调用 expungeStaleEntry 方法进行整理 (rehashing) 的操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). */private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 只要没有清理任何的 stale entries 并且 size 达到阈值的时候（即 table 已满，所有元素都可用），都会触发rehashing： 1234567891011121314151617181920212223/** * Re-pack and/or re-size the table. First scan the entire * table removing stale entries. If this doesn't sufficiently * shrink the size of the table, double the table size. */private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize();&#125;/** * Expunge all stale entries in the table. */private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125;&#125; rehash 操作会执行一次全表的扫描清理工作，并在 size 大于等于 threshold 的四分之三时进行 resize。但注意在 setThreshold 的时候又取了三分之二： 123456/** * Set the resize threshold to maintain at worst a 2/3 load factor. */private void setThreshold(int len) &#123; threshold = len * 2 / 3;&#125; 因此 ThreadLocalMap 的实际 load factor 为 3/4 * 2/3 = 0.5。 我们继续看 getEntry 的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125;/** * Version of getEntry method for use when key is not found in * its direct hash slot. * * @param key the thread local object * @param i the table index for key's hash code * @param e the entry at table[i] * @return the entry associated with key, or null if no such */private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; 逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用getEntryAfterMiss方法，根据线性探测法继续查找，直到找到或对应entry为null，并返回。 ThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法： 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; remove 方法的思想类似，直接放源码： 1234567891011121314151617/** * Remove the entry for key. */private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125;&#125; remove的时候同样也会调用expungeStaleEntry方法执行清理工作。 总结每个 Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的 ThreadLocal 被及时回收，不会造成内存泄露，又可以提升性能。假如我们把 ThreadLocalMap 做成一个 Map 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将 ThreadLocalMap 与线程相绑定的实现，完美地解决了这个问题。 总结一下什么时候无用的 Entry 会被清理： Thread 结束的时候插入元素时，发现 staled entry，则会进行替换并清理插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容调用 ThreadLocalMap 的 remove 方法或set(null) 时尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。 特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 remove 了。 总的来说，对于多线程资源共享的问题，同步机制采用了 以时间换空间 的方式，而 ThreadLocal 则采用了 以空间换时间 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbing.cc/categories/Java/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://zhangbing.cc/tags/ThreadLocal/"}]},{"title":"Android 源码分析之 AsyncTask 源码分析","slug":"AsyncTask20190228155539","date":"2019-02-28T07:54:26.000Z","updated":"2019-03-08T09:24:42.266Z","comments":true,"path":"2019/02/28/AsyncTask20190228155539/","link":"","permalink":"http://zhangbing.cc/2019/02/28/AsyncTask20190228155539/","excerpt":"Android 源码分析之 AsyncTask 源码分析1、AsyncTask的使用使用 AsyncTask 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 ThreadPoolExecutor 和 FutureTask等。AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 Params、Progress 和 Result，分别用来指定参数、进度和结果的值的类型。以及四个重要的方法，分别是 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()。这四个方法中，除了 doInBackground()，其他三个都是运行在UI线程的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 doInBackground() 运行在后台线程中，用来执行耗时的任务。","text":"Android 源码分析之 AsyncTask 源码分析1、AsyncTask的使用使用 AsyncTask 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 ThreadPoolExecutor 和 FutureTask等。AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 Params、Progress 和 Result，分别用来指定参数、进度和结果的值的类型。以及四个重要的方法，分别是 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()。这四个方法中，除了 doInBackground()，其他三个都是运行在UI线程的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 doInBackground() 运行在后台线程中，用来执行耗时的任务。 一种典型的使用方法如下： 123456789101112131415161718192021222324private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; @Override protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); if (isCancelled()) break; &#125; return totalSize; &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; setProgressPercent(progress[0]); &#125; @Override protected void onPostExecute(Long result) &#123; showDialog(\"Downloaded \" + result + \" bytes\"); &#125;&#125; 上面说 AsyncTask 有4个重要的方法，这里我们覆写了3个。doInBackground()运行在线程当中，耗时的任务可以放在这里进行；onProgressUpdate() 用来处理当任务的进度发生变化时候的逻辑；onPostExecute() 用来处理当任务执行完毕之后的逻辑。另外，这里我们还用到了 publishProgress() 和 isCancelled() 两个方法，分别用来发布任务进度和判断任务是否被取消。然后，我们可以用下面的方式来使用它： 1new DownloadFilesTask().execute(url1, url2, url3); 使用AsyncTask的时候要注意以下几点内容： AsyncTask 的类必须在主线程中进行加载，当在4.1之后这个过程会自动进行； AsyncTask 的对象必须在主线程中创建； execute()方法必须在UI线程中被调用； 不要直接调用 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()； 一个AsyncTask对象的 execute() 方法只能被调用一次； Android 1.6 之前，AsyncTask 是串行执行任务的；1.6 采用线程池处理并行任务；从 3.0 开始，又采用一个线程来串行执行任务。3.0 之后可以用 executeOnExecutor() 来并行地执行任务，如果我们希望在3.0之后能并行地执行上面的任务，那么我们应该这样去写： 1new DownloadFilesTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url1, url2, url3); 这里的 AsyncTask.THREAD_POOL_EXECUTOR 是 AsyncTask 内部定义的一个线程池，我们可以使用它来将 AsyncTask 设置成并行的。 2、AsyncTask源码分析2.1 AsyncTask 的初始化过程当初始化一个 AsyncTask 的时候，所有的重载构造方法都会调用下面的这个构造方法。这里做了几件事情： 初始化一个 Handler 对象 mHandler，该 Handler 用来将消息发送到它所在的线程中，通常使用默认的值，即主线程的 Handler； 初始化一个 WorkerRunnable 对象 mWorker。它是一个 WorkerRunnable 类型的实例，而 WorkerRunnable 又继承自 Callable，因此它是一个可以被执行的对象。我们会把在该对象中回调 doInBackground() 来将我们的业务逻辑放在线程池中执行。 初始化一个 FutureTask 对象 mFuture。该对象包装了 mWorker 并且当 mWorker 执行完毕之后会调用它的 postResultIfNotInvoked()方法来通知主线程（不论任务已经执行完毕还是被取消了，都会调用这个方法）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public AsyncTask(@Nullable Looper callbackLooper) &#123; // 1. 初始化用来发送消息的 Handler mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); // 2. 封装一个对象用来执行我们的任务 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 回调我们的业务逻辑 result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; // 发送结果给主线程 postResult(result); &#125; return result; &#125; &#125;; // 3. 初始化一个 FutureTask，并且当它执行完毕的时候，会调用 postResultIfNotInvoked 来将消息的执行结果发送到主线程中 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; // 如果任务没有被触发，也要发送一个结果 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 当这样设置完毕之后，我们就可以使用 execute() 方法来开始执行任务了。 2.2 AsyncTask 中任务的串行执行过程我们从 execute() 方法开始分析 AsyncTask: 12345678910111213141516171819@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; // 1.判断线程当前的状态 switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(...); case FINISHED: throw new IllegalStateException(...); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); // 2.回调生命周期方法 mWorker.mParams = params; // 3.赋值给可执行的对象 WorkerRunnable exec.execute(mFuture); // 4.在线程池中执行任务 return this;&#125; 当我们调用 AsyncTask 的 execute() 方法的时候会立即调用它的 executeOnExecutor() 方法。这里传入了两个参数，分别是一个 Executor 和任务的参数 params。从上面我们可以看出，当直接调用 execute() 方法的时候会使用默认的线程池 sDefaultExecutor，而当我们指定了线程池之后，会使用我们指定的线程池来执行任务。在 1 处，会对 AsyncTask 当前的状态进行判断，这就对应了前面说的，一个任务只能被执行一次。在 2 处会调用onPreExecute()方法，如果我们覆写了该方法，那么它就会在这个时候被调用。在 3 处的操作是在为 mWorker 赋值，即把调用 execute 方法时传入的参数赋值给了 mWorker。接下来，会将 mFuture 添加到线程池中执行。当我们不指定任何线程池的时候使用的 sDefaultExecutor 是一个串行的线程池，它的定义如下： 1234567891011121314151617181920212223242526272829303132public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; // 相当于对传入的Runnable进行了一层包装 r.run(); &#125; finally &#123; // 分配下一个任务 scheduleNext(); &#125; &#125; &#125;); // 如果当前没有正在执行的任务，那么就尝试从队列中取出并执行 if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; // 从队列中取任务并使用THREAD_POOL_EXECUTOR执行 if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 从上面我们可以看出，我们添加到线程池中的任务实际上并没有直接交给线程池来执行，而是对其进行了处理之后才执行的，SerialExecutor 通过内部维护了双端队列，每当一个 AsyncTask 调用 execute() 方法的时候都会被放在该队列当中进行排队。如果当前没有正在执行的任务，那么就从队列中取一个任务交给 THREAD_POOL_EXECUTOR 执行；当一个任务执行完毕之后又会调用 scheduleNext() 取下一个任务执行。也就是说，实际上 sDefaultExecutor 在这里只是起了一个任务调度的作用，任务最终还是交给 THREAD_POOL_EXECUTOR 执行的。这里的THREAD_POOL_EXECUTOR也是一个线程池，它在静态代码块中被初始化： 12345678static &#123; // 使用指定的参数创建一个线程池 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 我们也可以直接将这个静态的线程池作为我们任务执行的线程池而不是放在上面的队列中被串行地执行。 2.3 将任务执行的结果发送到其他线程上面的 WorkerRunnable 中已经用到了 postResult 方法，它用来将任务执行的结果发送给 Handler： 123456private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; mHandler 会在创建 AsyncTask 的时候初始化。我们可以通过 AsyncTask 的构造方法传入 Handler 和 Looper 来指定该对象所在的线程。当我们没有指定的时候，会使用 AsyncTask 内部的 InternalHandler 创建 Handler： 123456789101112131415161718192021222324252627282930313233private final Handler mHandler;public AsyncTask(@Nullable Looper callbackLooper) &#123; // 根据传入的参数创建Handler对象 mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper);&#125;private static Handler getMainHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; // 使用 InternalHandler 创建对象 sHandler = new InternalHandler(Looper.getMainLooper()); &#125; return sHandler; &#125;&#125;// AsyncTask 内部定义 的Handler 类型private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; // 根据传入的消息类型进行处理 switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 3、总结上面我们梳理了 AsyncTask 的大致过程，我们来梳理下：每当我们实例化一个 AsyncTask 的时候都会在内部封装成一个 Runnable 对象，该对象可以直接放在线程池中执行。这里存在两个线程池，一个是 SerialExecutor 一个是 THREAD_POOL_EXECUTOR，前者主要用来进行任务调度，即把交给线程的任务放在队列中进行排队执行，而时机上所有的任务都是在后者中执行完成的。这个两个线程池都是静态的字段，所以它们对应于整个类的。也就是说，当使用默认的线程池的时候，实例化的 AsyncTask 会一个个地，按照加入到队列中的顺序依次执行。","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangbing.cc/categories/Android/"}],"tags":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"http://zhangbing.cc/tags/AsyncTask/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-18T01:59:04.000Z","updated":"2019-02-28T07:54:22.337Z","comments":true,"path":"2018/12/18/hello-world/","link":"","permalink":"http://zhangbing.cc/2018/12/18/hello-world/","excerpt":"","text":"换硬盘博客都丢了,就从头再来吧!","categories":[],"tags":[]}]}